<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>INKY Toolbox</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* --- CSS Variables (From Tombola) --- */
        :root {
            --bg-color-main: #2E3A46;
            --bg-color-gradient-light: #3C4F65;
            --bg-color-gradient-dark: #4A5A6A;
            --bg-color-box: rgba(81, 100, 118, 0.5);
            --text-color-light: #fff;
            --text-color-accent: #E5C07B; /* Yellowish Gold */
            --border-color: rgba(255, 255, 255, 0.2);
            --color-link: #61afef; /* Blue/Cyan for links */
            --color-link-hover: #559bd7;
            --color-revoke-btn: #FF4D4D; /* Red for Revoke */
            --color-revoke-btn-hover: #CC0000;
        }

        /* --- BASE & ANIMATIONS --- */
        html {
            scroll-behavior: smooth; 
        }
        html, body {
            margin: 0; padding: 0; 
            min-height: 100vh; 
            font-family: 'Poppins', sans-serif; color: var(--text-color-light);
            background: linear-gradient(270deg, var(--bg-color-gradient-light), var(--bg-color-main), var(--bg-color-gradient-dark), #6C7A89);
            background-size: 800% 800%;
            animation: gradientBG 20s ease infinite;
            position: relative; 
            overflow-x: hidden; 
        }

        body {
            overflow: hidden;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
         @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes floatSlow {
            0% { transform: translate(0, 0); } 25% { transform: translate(25px, 20px) scale(1); }
            50% { transform: translate(-20px, 25px) scale(0.95); } 75% { transform: translate(20px, -20px) scale(1.05); }
            100% { transform: translate(0, 0) scale(1); }
        }
        
        .floating-logo {
            position: absolute;
            width: 120px;
            opacity: 0.15;
            pointer-events: none;
            animation: floatSlow 25s ease-in-out infinite;
        }


        /* --- HEADER & NAVIGATION (FIXED) --- */
        header {
            display: flex; justify-content: space-between; align-items: center; 
            padding: 10px 20px; height: 80px; box-sizing: border-box;
            background: rgba(0,0,0,0.35); box-shadow: 0 2px 10px rgba(0,0,0,0.4);
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            z-index: 100; 
        }
        .logo {
            display: flex; align-items: center; gap: 5px; 
            cursor: pointer;
            transition: transform 0.3s;
        }
        .logo:hover {
            transform: scale(1.05);
        }
        .logo img {
            height: 65px; 
            width: auto;
            transition: transform 0.3s;
        }
        .logo:hover img {
            transform: scale(1.05);
        }
        
        .logo span {
            font-size: 17px; 
            font-weight: 700; 
            color: var(--text-color-light); 
            letter-spacing: 0.5px;
        }

        /* Navigation Styles */
        .nav-tabs { 
            display: flex; 
            align-items: center; 
            gap: 20px; 
        }
        .nav-tabs a {
            color: var(--text-color-light); text-decoration: none; 
            font-size: 15px; font-weight: 600; cursor: pointer; 
            position: relative; transition: color 0.3s;
            padding: 5px 0;
        }
        .nav-tabs a::after {
            content: ''; display: block; width: 0; height: 3px; 
            background: var(--text-color-accent); transition: width 0.3s; 
            position: absolute; bottom: -8px; left: 0;
        }

        .nav-tabs a.active {
            color: var(--text-color-accent);
        }
        .nav-tabs a.active::after {
            width: 100%;
        }
        
        /* Hamburger Menu */
        .hamburger {
            display: none;
            flex-direction: column;
            cursor: pointer;
            padding: 8px;
            z-index: 101;
            background: rgba(229, 192, 123, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(229, 192, 123, 0.3);
        }
        
        .hamburger span {
            width: 25px;
            height: 3px;
            background: var(--text-color-accent);
            margin: 3px 0;
            transition: 0.3s;
            border-radius: 2px;
        }
        
        /* Hamburger animation when active */
        .hamburger.active span:nth-child(1) {
            transform: rotate(-45deg) translate(-5px, 6px);
        }
        
        .hamburger.active span:nth-child(2) {
            opacity: 0;
        }
        
        .hamburger.active span:nth-child(3) {
            transform: rotate(45deg) translate(-5px, -6px);
        }

        /* Connect Button */
        .button {
            padding: 10px 5px;
            font-size: 11px;
            font-weight: bold;
            color: var(--text-color-light);
            width: 200px; 
            background: linear-gradient(270deg, var(--bg-color-gradient-dark), var(--bg-color-main), #6C7A89, var(--bg-color-gradient-dark));
            background-size: 600% 600%;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s, color 0.3s, background 0.5s;
        }

        .button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px 3px #6C7A89;
            animation: gradientAnimation 3s ease infinite;
            color: var(--text-color-accent);
        }
        .connected { 
            color: var(--text-color-accent); 
            animation: none; 
        }

        /* --- MAIN CONTENT & TOOLBOX SPECIFIC STYLES --- */
        main {
            padding: 40px 20px; max-width: 1200px; margin: 0 auto;
            margin-top: 80px;
        }
        .test-content-spacer {
            height: 150vh; 
            background: transparent;
        }

        .toolbox-container {
            background: var(--bg-color-box); border-radius: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5); padding: 30px;
        }
        
        .toolbox-header {
            display: flex; align-items: center; justify-content: center;
            gap: 15px; margin-bottom: 20px;
        }
        .toolbox-header h2 {
            font-size: 28px; margin: 0; color: var(--text-color-light);
            font-weight: 600;
        }
        .toolbox-header i {
            font-size: 30px; color: var(--color-link);
        }
        
        .toolbox-description {
            text-align: center; font-size: 16px; margin-bottom: 30px;
            color: #DDE4EC;
        }
        
        .approvals-table-container {
            max-height: 400px; overflow-y: auto;
            border: 1px solid var(--border-color); border-radius: 10px;
            scrollbar-width:thin; 
            scrollbar-color:rgb(100, 110, 120) rgb(68, 75, 82);
        }
        
        table {
            width: 100%; border-collapse: collapse; font-size: 14px;
        }
        table thead {
            position: sticky; top: 0; background: var(--bg-color-gradient-dark);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 10;
        }
        table th, table td {
            padding: 12px 15px; text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            word-break: break-word;
        }
        table th {
            color: var(--text-color-accent); font-weight: 700;
        }
        table tr:last-child td { border-bottom: none; }
        table tbody tr:hover { background: rgba(255, 255, 255, 0.05); }

        .revoke-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .revoke-btn:hover {
            background: #c0392b;
            transform: translateY(-1px);
        }

        .revoke-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .revoke-btn:active {
            transform: translateY(0);
        }

        .no-data-message {
            cursor: pointer;
            padding: 20px;
            text-align: center;
            color: #666;
            font-style: italic;
        }

        #walletPopup {
            display: none; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            position: fixed; z-index: 1000; background: var(--bg-color-main); 
            padding: 20px; border-radius: 15px; min-width: 250px; 
            box-shadow: 0 0 15px 3px #6C7A89;
        }
        #walletPopup button {
            display: block; margin: 10px 0; padding: 10px; width: 100%; 
            cursor: pointer; border-radius: 10px; border: none; 
            background: var(--bg-color-gradient-dark); color: var(--text-color-light); 
            font-weight: bold; transition: background 0.3s;
        }
        #walletPopup button:hover { background: #6C7A89; }
        #popupOverlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; 
            height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 999;
        }
        #loader {
            display: none; position: fixed; top: 0; left: 0; width: 100%; 
            height: 100%; background: rgba(0, 0, 0, 0.5); color: white; 
            font-size: 2em; text-align: center; padding-top: 20%; z-index: 1000;
        }
        #errorPopup {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%); 
            background-color: #ff4d4f; color: white; padding: 12px 24px; 
            border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); 
            display: none; font-family: sans-serif; font-size: 14px; z-index: 1001;
        }

        /* --- MULTI-SENDER SPECIFIC STYLES --- */
        .multisender-form-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-color-accent);
        }

        #tokenSelect,
        #recipientsInput {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--bg-color-main);
            color: var(--text-color-light);
            font-size: 14px;
            box-sizing: border-box;
        }

        #recipientsInput {
            font-family: monospace;
            resize: vertical;
        }

        #recipientsInput.invalid {
            background-color: rgba(255, 77, 77, 0.08);
            border-color: var(--color-revoke-btn);
        }

        .total-over {
            color: var(--color-revoke-btn) !important;
        }

        .input-hint {
            font-size: 12px;
            color: #A0AEC0;
            margin-top: 5px;
        }

        .summary-box {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .summary-risks {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
        }

        .summary-box p {
            margin: 5px 0;
            font-size: 15px;
        }

        .summary-risks p {
            margin: 5px 0;
            font-size: 15px;
        }

        #sendBatchButton {
            width: 100%;
            padding: 15px;
            font-size: 16px;
        }

        .multisender-columns {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 25px;
        }

        .multisender-left,
        .multisender-right {
            display: flex;
            flex-direction: column;
        }

        .multisender-right .wallet-balance {
            margin-bottom: 20px;
            font-size: 14px;
            color: #DDE4EC;
        }

        .risk-analyzer-form {
            max-width: 500px;
            margin: 0 auto;
            display: flex;
            gap: 10px;
            flex-wrap: nowrap;
            align-items: flex-end;
        }

        .risk-analyzer-form .input-risk {
            flex: 2;
            display: flex;
            color: #E5C07B;
            font-weight: bold;
            flex-direction: column;
            justify-content: flex-end; 
            margin-bottom: 0;
        }
        #tokenAddressInput {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color-main);
            color: var(--text-color-light);
            font-size: 13.5px;
            box-sizing: border-box;
        }

        #analyzeTokenButton {
            padding: 10px 20px; 
            flex: 0 0 auto;
            height: auto; 
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            color: var(--text-color-light);
            font-size: 14px;
            background: linear-gradient(270deg, var(--bg-color-gradient-dark), var(--bg-color-main), #6C7A89, var(--bg-color-gradient-dark));
            background-size: 600% 600%;
            transition: transform 0.3s, box-shadow 0.3s, color 0.3s, background 0.5s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #analyzeTokenButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px 3px #6C7A89;
            animation: gradientAnimation 3s ease infinite;
            color: var(--text-color-accent);
        }

        .screener-form {
            max-width: 500px;
            margin: 0 auto;
            display: flex;
            gap: 10px;
            flex-wrap: nowrap;
            align-items: flex-end;
        }

        .screener-form .input-screener {
            flex: 2;
            display: flex;
            color: #E5C07B;
            font-weight: bold;
            flex-direction: column;
            justify-content: flex-end; 
            margin-bottom: 0;
        }
        #tokenAddressScreener {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color-main);
            color: var(--text-color-light);
            font-size: 13.5px;
            box-sizing: border-box;
        }

        #screenerButton {
            padding: 10px 20px; 
            flex: 0 0 auto;
            height: auto; 
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            color: var(--text-color-light);
            font-size: 14px;
            background: linear-gradient(270deg, var(--bg-color-gradient-dark), var(--bg-color-main), #6C7A89, var(--bg-color-gradient-dark));
            background-size: 600% 600%;
            transition: transform 0.3s, box-shadow 0.3s, color 0.3s, background 0.5s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #screenerButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px 3px #6C7A89;
            animation: gradientAnimation 3s ease infinite;
            color: var(--text-color-accent);
        }

        .vesting-tracker-form {
            max-width: 500px;
            margin: 0 auto;
            display: flex;
            gap: 10px;
            flex-wrap: nowrap;
            align-items: flex-end;
        }

        .vesting-tracker-form .input-vesting {
            flex: 2;
            display: flex;
            color: #E5C07B;
            font-weight: bold;
            flex-direction: column;
            justify-content: flex-end; 
            margin-bottom: 0;
        }
        #tokenAddressVesting {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color-main);
            color: var(--text-color-light);
            font-size: 13.5px;
            box-sizing: border-box;
        }

        #buttonVesting {
            padding: 10px 20px; 
            flex: 0 0 auto;
            height: auto; 
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            color: var(--text-color-light);
            font-size: 14px;
            background: linear-gradient(270deg, var(--bg-color-gradient-dark), var(--bg-color-main), #6C7A89, var(--bg-color-gradient-dark));
            background-size: 600% 600%;
            transition: transform 0.3s, box-shadow 0.3s, color 0.3s, background 0.5s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #buttonVesting:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px 3px #6C7A89;
            animation: gradientAnimation 3s ease infinite;
            color: var(--text-color-accent);
        }

        .vesting-table-container {
            max-height: 400px; 
            overflow-y: auto;
            border: 1px solid var(--border-color); 
            border-radius: 10px;
        }

        .no-data-message {
            text-align: center;
            padding: 20px;
            font-style: italic;
            color: var(--text-color-light);
        }

        .analyze-link {
            color: #2f93f7;
            font-weight: bold;
            cursor: pointer;
            text-decoration: underline;
        }

        .analyze-link:hover {
            color: #bdd0e3;
        }

        /* --- RESPONSIVE DESIGN --- */
        @media (max-width: 1024px) {
            .multisender-columns {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .toolbox-container {
                padding: 20px;
            }
        }

        @media (max-width: 800px) {
            body { 
                padding-top: 0;
            }

            main {
                margin-top: 100px;
            }

            header { 
                flex-wrap: wrap; 
                height: auto; 
                padding: 15px 20px; 
                position: fixed;
            }
            
            /* Show hamburger and hide default links */
            .hamburger {
                display: flex !important;
            }
            
            .nav-tabs {
                display: none !important;
                position: fixed;
                top: 80px;
                left: 0;
                width: 100%;
                height: 100vh;
                background: rgba(44, 58, 71, 0.98);
                flex-direction: column;
                padding: 30px 25px;
                z-index: 999;
                backdrop-filter: blur(10px);
                overflow-y: auto;
            }

            .button,
            .logo,
            .hamburger,
            .nav-tabs a,
            .revoke-btn,
            #analyzeTokenButton,
            #screenerButton,
            #buttonVesting,
            #sendBatchButton {
                -webkit-tap-highlight-color: transparent;
                outline: none;
            }
            
            .nav-tabs.active {
                display: flex !important;
            }
            
            .nav-tabs a {
                margin: 0 0 10px 0;
                padding: 18px 25px 18px 30px;
                border-bottom: 1px solid rgba(229, 192, 123, 0.2);
                font-size: 18px;
                width: 100%;
                background: transparent;
                transition: background 0.3s;
                border-radius: 8px;
            }
            
            .nav-tabs a:hover {
                background: rgba(229, 192, 123, 0.15);
            }
            
            .nav-tabs a::after {
                display: none;
            }
            
            .button { 
                width: 100%; 
                margin-top: 15px;
            }
            
            table th, table td { 
                padding: 2px 2px; 
                font-size: 11px; 
            }

            .toolbox-container {
                margin-top: 7px; 
            }

            .toolbox-header h2 { 
                font-size: 24px; 
            }
            
            .risk-analyzer-form,
            .screener-form,
            .vesting-tracker-form {
                flex-direction: column;
                align-items: stretch;
            }
            
            #analyzeTokenButton,
            #screenerButton,
            #buttonVesting {
                width: 100%;
                margin-top: 10px;
            }
        }
        
        @media (max-width: 600px) {
            body { 
                padding-top: 0;
            }

            main {
                margin-top: 80px;
            }
            
            header {
                padding: 10px 15px;
            }
            
            .logo img { 
                height: 50px; 
            }
            .logo span { 
                font-size: 18px; 
            }
            
            .button,
            .logo,
            .hamburger,
            .nav-tabs a,
            .revoke-btn,
            #analyzeTokenButton,
            #screenerButton,
            #buttonVesting,
            #sendBatchButton {
                -webkit-tap-highlight-color: transparent;
                outline: none;
            }

            .revoke-btn {
                font-size: 12px;
            }

            .toolbox-header {
                flex-direction: column;
                gap: 10px;
            }
            
            .toolbox-header h2 {
                font-size: 22px;
            }
            
            .toolbox-description {
                font-size: 14px;
            }
            
            .multisender-form-container {
                padding: 15px;
            }
            
            .summary-box,
            .summary-risks {
                padding: 10px;
            }
            
            .revoke-btn { 
                padding: 6px 10px; 
                font-size: 12px; 
            }
            
            table {
                font-size: 11px;
            }
            
            table th, table td {
                padding: 2px 2px;
            }
        }
        
        @media (max-width: 400px) {
            body { 
                padding-top: 0;
            }

            main {
                margin-top: 80px;
            }
            
            .logo span {
                font-size: 16px;
            }

            .button,
            .logo,
            .hamburger,
            .nav-tabs a,
            .revoke-btn,
            #analyzeTokenButton,
            #screenerButton,
            #buttonVesting,
            #sendBatchButton {
                -webkit-tap-highlight-color: transparent;
                outline: none;
            }
            
            .toolbox-header h2 {
                font-size: 20px;
            }
            
            .floating-logo {
                width: 80px;
            }
        }

    </style>
</head>

<body>
    <header>
        <div class="logo" id="logo"> 
            <img src="inky-logo.png" alt="INKY Logo">
            <span>INKY Toolbox</span>
        </div>
        
        <nav class="nav-tabs" id="navTabs">
            <a href="#screener-tool" class="active" data-tool="screener">Wallet Screener</a>
            <a href="#approval-checker-tool" data-tool="approval-checker">Approval Checker</a>
            <a href="#vesting-tracker-tool" data-tool="vesting-tracker">Vesting Tracker</a>
            <a href="#risk-analyzer-tool" data-tool="risk-analyzer">Risk Analyzer</a>
            <a href="#multisend-tool" data-tool="multisend">Multi-Sender</a> 
        </nav>
        
        <div class="hamburger" id="hamburger">
            <span></span>
            <span></span>
            <span></span>
        </div>
        
        <button class="button" id="connectButton">Connect Wallet</button>
    </header>

    <main>
        
        <div class="toolbox-container" id="toolContainer">
            
            <div id="approval-checker-tool" style="display:none">
                <div class="toolbox-header">
                    <i class="fas fa-shield-alt"></i>
                    <h2>Approval Checker</h2>
                </div>
                <p class="toolbox-description">
                    Check and revoke the allowances (approvals) you've granted to third-party smart contracts on your tokens. Secure your wallet by revoking unnecessary or risky access. This often-ignored step is the main source of smart contract hacks and wallet drains.
                </p>
                                
                <div class="approvals-table-container">
                    <table id="approvalsTable">
                        <thead>
                            <tr>
                                <th style="width: 25%;">Token</th>
                                <th style="width: 40%;">Spender</th>
                                <th style="width: 20%;">Allowance</th>
                                <th style="width: 15%;">Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr id="initialRow">
                                <td colspan="4" class="no-data-message">
                                    Click <span class="analyze-link">here</span> to view your wallet approvals
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
        <div id="multisend-tool" style="display:none;">
            <div class="toolbox-header">
                <i class="fas fa-paper-plane"></i>
                <h2>Multi-Sender</h2>
            </div>
            <p class="toolbox-description">
                Batch transfers drastically reduce your overall transaction volume, allowing you to efficiently consolidate multiple sends into a single, optimized operation, an essential tool for streamlined distribution and treasury management on the NXRA Chain, where 
                it also contributes to keeping your transaction costs minimal.
            </p>

        <div class="multisender-form-container">
            <div class="multisender-columns">
                <!-- Colonne gauche -->
                <div class="multisender-left">
                    <div class="input-group">
                        <label for="recipientsInput">Recipients and Amounts</label>
                        <textarea id="recipientsInput" rows="16" placeholder="0xAbCdEf...1234, 100.5&#10;0xGhIjKl...5678, 250&#10;0xMnOpQr...9012, 50.75"></textarea>
                        <p class="input-hint">Format: `Address, Amount` - Separate with a comma.</p>
                    </div>
                </div>

                <!-- Colonne droite -->
                <div class="multisender-right">
                    <div class="input-group">
                        <label for="tokenSelect">Token to send:</label>
                        <select id="tokenSelect">
                            <option value="NXRA">NXRA</option>
                        </select>
                    </div>

                    <div class="wallet-balance">
                        <p>Available Balance: <strong id="availableTokenBalance">-</strong> <span id="availableTokenSymbol">NXRA</span></p>
                    </div>

                    <div class="summary-box">
                        <p>Total Recipients: <strong id="totalRecipients">-</strong></p>
                        <p>Total Amount: <strong id="totalAmount">-</strong> <span id="summaryTokenSymbol">NXRA</span></p>
                    </div>

                    <button class="button" id="sendBatchButton">Send Batch</button>
                    <p class="error-message" id="multiSendError" style="display:none; color: var(--color-revoke-btn); text-align:center; margin-top: 10px;"></p>
                </div>
            </div>
        </div>

        </div>
            
            <div id="screener-tool">
                <div class="toolbox-header">
                    <i class="fas fa-search"></i>
                    <h2>Wallet Screener</h2>
                </div>
                <p class="toolbox-description">
                    Instantly explore any wallet on the Nexera Chain, view its token holdings, recent activity across assets, and ranking among other holders, all with clarity and insight.
                </p>
                <div class="screener-form">
                    <div class="input-screener">
                        <label for="tokenAddressScreener">Wallet Address:</label>
                        <input type="text" id="tokenAddressScreener" placeholder="0x..." autocomplete="false-address"/>
                    </div>
                    <button id="screenerButton">Analyze Address</button>
                </div>

                <div class="own-wallet"; style="text-align: center; font-size: 12px";>Leave empty and click to analyze connected wallet</div>
            </div>

        <div id="vesting-tracker-tool" style="display:none;">
            <div class="toolbox-header">
                <i class="fas fa-clock"></i>
                <h2>Vesting Tracker</h2>
            </div>
            <p class="toolbox-description">
                Track the status of locked token allocations (vesting) across any contract. Easily view upcoming unlock dates and the amounts that will become available.
            </p>
            <div class="vesting-tracker-form">
                <div class="input-vesting">
                    <label for="tokenAddressVesting">Token Contract Address:</label>
                    <input type="text" id="tokenAddressVesting" placeholder="0x..." autocomplete="off"/>
                </div>
                <button id="buttonVesting">Analyze Token</button>
            </div>

            <div class="vesting-table-container" style="margin-top: 20px;">
                <table id="vestingTable">
                    <thead>
                        <tr>
                            <th style="width: 20%;">Ticker</th>
                            <th style="width: 30%;">Vesting</th>
                            <th style="width: 20%;">Schedule</th>
                            <th style="width: 30%;">Next Unlock</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr id="initialVestingRow"><td colspan="4" class="no-data-message">Enter the contract address and click on 'Analyze Token'</td></tr>
                        </tbody>
                </table>

            </div>
        </div>

        <div id="risk-analyzer-tool" style="display:none;">
            <div class="toolbox-header">
                <i class="fas fa-exclamation-triangle"></i>
                <h2>Risk Analyzer</h2>
            </div>
            <p class="toolbox-description">
                Evaluate reliably the security of any token (even new meme coins) by analyzing its contract. Check if the code allows for centralized control, if the token is mintable, if it shows honeypot potential, if liquidity is locked, and if it's prone to a rug pull.
            </p>

            <div class="risk-analyzer-form">
                <div class="input-risk">
                    <label for="tokenAddressInput">Token Contract Address:</label>
                    <input type="text" id="tokenAddressInput" placeholder="0x..." autocomplete="off"/>
                </div>
                <button id="analyzeTokenButton">Analyze Token</button>
            </div>

            <div id="riskResults" style="margin-top:20px; display:block;">
                <div class="summary-risks">
                    <p>Centralized Control: <strong id="centralisedControlStatus">-</strong></p>
                    <p>Mintable: <strong id="mintableStatus">-</strong></p>
                    <p>Honeypot Risk: <strong id="honeypotStatus">-</strong></p>
                    <p>Liquidity Locked: <strong id="liquidityStatus">-</strong></p>                   
                    <p>Rug Pull Risk: <strong id="rugpullStatus">-</strong></p>
                </div>
            </div>
        </div>
            </div>
        <div class="test-content-spacer"></div>
    </main>
    <!-- Honeypot Details Modal -->
    <div id="honeypotModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); z-index:1000; justify-content:center; align-items:center;">
        <div class="modal-content" style="background:rgb(67, 76, 85); padding:20px; border-radius:10px; max-width:500px; width:90%; position:relative;">
            <span id="closeHoneypotModal" style="position:absolute; top:10px; right:15px; cursor:pointer; font-weight:bold; font-size:18px;">&times;</span>
            <h3>Honeypot Risk Details</h3>
            <ul id="honeypotDetailsList" style="padding-left:20px; max-height:400px; overflow-y:auto; margin-top:10px; scrollbar-width:thin; scrollbar-color:rgb(100, 110, 120) rgb(68, 75, 82);"></ul>
        </div>
    </div>

    
    <div id="popupOverlay"></div>
    <div id="walletPopup">
    </div>
    <div id="loader"></div>
    <div id="errorPopup"></div>

    <img src="NXRA-logo.png" class="floating-logo" style="top:5%;left:10%; animation-delay:0s;">
    <img src="inky-logo.png" class="floating-logo" style="top:20%;left:30%; animation-delay:2s;">
    <img src="NXRA-logo.png" class="floating-logo" style="top:35%;left:50%; animation-delay:4s;">
    <img src="inky-logo.png" class="floating-logo" style="top:50%;left:70%; animation-delay:6s;">
    <img src="NXRA-logo.png" class="floating-logo" style="top:65%;left:20%; animation-delay:1s;">
    <img src="inky-logo.png" class="floating-logo" style="top:70%;left:50%; animation-delay:3s;">
    <img src="inky-logo.png" class="floating-logo" style="top:10%;left:60%; animation-delay:5s;">
    <img src="NXRA-logo.png" class="floating-logo" style="top:25%;left:80%; animation-delay:7s;">
    <img src="NXRA-logo.png" class="floating-logo" style="top:40%;left:15%; animation-delay:2.5s;">
    <img src="inky-logo.png" class="floating-logo" style="top:55%;left:35%; animation-delay:4.5s;">
    <img src="NXRA-logo.png" class="floating-logo" style="top:70%;left:80%; animation-delay:6.5s;">
    <img src="inky-logo.png" class="floating-logo" style="top:70%;left:6%; animation-delay:8s;">
    <img src="NXRA-logo.png" class="floating-logo" style="top:90%;left:70%; animation-delay:4s;">
    <img src="inky-logo.png" class="floating-logo" style="top:90%;left:25%; animation-delay:1s;">


<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script> 

<script>
// ===== DEPENDENCY CHECK =====
if (typeof ethers === 'undefined') {
    console.error("Ethers.js library not loaded. Check the script import.");
}

// ===== CONFIGURATION CONSTANTS =====
const NXRA_CHAIN = {
    name: "Nexera Testnet",
    chainId: 72080, 
    chainIdHex: "0x11990",
    RPC_URL: "https://rpc.testnet.nexera.network", 
    API_BASE_URL: "https://explorer.testnet.nexera.network/", 
};

const MULTISEND_ABI = [
    "function multisendNative(address[] recipients, uint256[] amounts) payable",
    "function multisendERC20(address token, address[] recipients, uint256[] amounts)",
];

const INKY_TOOLBOX_CONFIG = {
    ADDRESS: "0x6EB2C1fE4e3B48af4905A0209658810B61343438",
    MIN_BALANCE_FOR_USE: 5000,
};

const BASIC_INKY_ABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function balanceOf(address owner) view returns (uint256)",
    "function decimals() view returns (uint8)"
];

const HONEYPOT_FUNCTIONS = {
    "setMaxTransferAmount": "Owner can set max transfer to zero, blocking sales.",
    "setMaxSellAmount": "Owner can restrict quantity sold, impacting liquidity.",
    "setBlackList": "Owner can block any address from transferring tokens.",
    "setTaxFeePercent": "Owner can raise transfer/sale taxes to 100% at any time.",
    "transferOwnership": "Owner can give full control to a new, potentially unknown, address.", 
    "enableTrading": "Owner can pause trading, trapping investors.",
    "setTradingEnabled": "Owner can pause trading, trapping investors.",
    "setTradingStatus": "Owner can pause trading, trapping investors.",
    "updateOwner": "Owner can give full control to a new, potentially unknown, address.",
    "setMaxTxAmount": "Owner can set max transfer to zero, blocking sales.",
    "setMaxWallet": "Owner can restrict wallet holdings.",
    "setWhitelist": "Owner can control who can trade.",
    "excludeFromFee": "Owner can manipulate fees.",
    "includeInFee": "Owner can manipulate fees.",
    "setSwapAndLiquifyEnabled": "Owner can manipulate liquidity."
};

const MULTISEND_ADDRESS = "0x3f9c8E5df3DeEf77A8F8994f25FE23f8968e8C62";
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";

// ===== GLOBAL VARIABLES =====
const DOM_ELEMENTS = {};
let inkyBalance = 0n;
let inkyDecimals = 18;

// ===== UTILITY FUNCTIONS =====
function showError(message) { 
    if (DOM_ELEMENTS.errorPopup) { 
        DOM_ELEMENTS.errorPopup.textContent = message;
        DOM_ELEMENTS.errorPopup.style.display = 'block';
        setTimeout(() => { DOM_ELEMENTS.errorPopup.style.display = 'none'; }, 3500);
    } else { 
        console.error("Error: DOM element 'errorPopup' is missing.", message);
    } 
} 

function showLoader(message = "Processing...") { 
    if (DOM_ELEMENTS.loader) { 
        DOM_ELEMENTS.loader.textContent = message;
        DOM_ELEMENTS.loader.style.display = 'block';
    } 
} 

function hideLoader() { 
    if (DOM_ELEMENTS.loader) { 
        DOM_ELEMENTS.loader.style.display = 'none';
    } 
} 

function truncateAddress(address) { 
    if (!address) return "Not Connected";
    const addr = address.toLowerCase();
    return addr.substring(0, 6) + "..." + addr.substring(addr.length - 4);
} 

async function fetchInkyBalance() {
    if (!walletManager.getReadProvider() || !walletManager.getUserAddress()) return;
    try {
        const inkyContract = new ethers.Contract(INKY_TOOLBOX_CONFIG.ADDRESS, BASIC_INKY_ABI, walletManager.getReadProvider());
        if (inkyDecimals === 18) { 
             inkyDecimals = Number(await inkyContract.decimals());
        }

        const balanceBigInt = await inkyContract.balanceOf(walletManager.getUserAddress());
        const balanceFormatted = ethers.formatUnits(balanceBigInt, inkyDecimals);
        
        inkyBalance = Number(balanceFormatted); 
    } catch (error) {
        console.error("Error fetching INKY balance:", error);
        inkyBalance = 0;
    }
}

async function verifyInkyBalance(minBalance = INKY_TOOLBOX_CONFIG.MIN_BALANCE_FOR_USE) {
    if (!walletManager.getUserAddress()) {
        showError("Please connect your wallet first.");
        return false;
    }
    
    if (!walletManager.getReadProvider()) {
        showError("RPC Provider not initialized. Cannot check INKY balance.");
        return false;
    }

    await fetchInkyBalance();

    if (inkyBalance < minBalance) {
        showError(`You must hold at least ${minBalance.toLocaleString()} INKY to use this feature.`);
        return false;
    }

    DOM_ELEMENTS.errorPopup.style.display = 'none';
    return true;
}

async function getNativeBalance(address) {
    if (!address) return 0n;
    try {
        const provider = new ethers.JsonRpcProvider(NXRA_CHAIN.RPC_URL);
        const balance = await provider.getBalance(address);
        return balance;
    } catch (error) {
        console.error("Error fetching native balance:", error);
        return 0n;
    }
}

async function fetchTokenList(address) {
    if (!address) return [];

    const url = `${NXRA_CHAIN.API_BASE_URL}api?module=account&action=tokenlist&address=${address}`; 

    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status} ${response.statusText}`);
        }
        const data = await response.json();
        
        console.log("API Explorer Raw Token List:", data.result); 

        if (data.status === '1' && Array.isArray(data.result)) {
            return data.result.map(token => ({
                contractAddress: token.contractAddress,
                symbol: token.symbol,
                balance: BigInt(token.balance),
                decimals: parseInt(token.decimals) 
            }));
        } else {
            console.warn("API returned status 0 or empty result for token list:", data.message || "No ERC-20 tokens found.");
            return [];
        }
    } catch (error) {
        console.error("Fetch failed for token list.", error);
        return [];
    }
}

function cacheDOMElements() {
    DOM_ELEMENTS.errorPopup = document.getElementById('errorPopup');
    DOM_ELEMENTS.loader = document.getElementById('loader');
    DOM_ELEMENTS.navLinks = document.querySelectorAll('.nav-tabs a');
}

// ===== WALLET MANAGER CLASS =====
class WalletManager {
    constructor() {
        this.userAddress = null;
        this.provider = null;
        this.readProvider = null;
        this.isWalletConnected = false;
        this.currentChainIdDisplay = "Not Connected";
        this.walletName = null;
        
        this.domElements = {};
        this.cacheDOMElements();
        this.setupEventListeners();
    }

    cacheDOMElements() {
        this.domElements.connectButton = document.getElementById('connectButton');
        this.domElements.popupOverlay = document.getElementById('popupOverlay');
        this.domElements.walletPopup = document.getElementById('walletPopup');
    }

    setupEventListeners() {
        if (this.domElements.connectButton) {
            this.domElements.connectButton.addEventListener('click', () => this.handleConnectButtonClick());
        }
        if (this.domElements.popupOverlay) {
            this.domElements.popupOverlay.addEventListener('click', () => this.closeWalletPopup());
        }
        this.attachProviderListeners();
    }

    getWalletName(p) {
        if (p.isRabby) return "Rabby Wallet";
        if (p.isTrust) return "Trust Wallet"; 
        if (p.isCoinbaseWallet) return "Coinbase Wallet";
        if (p.isBraveWallet) return "Brave Wallet";
        if (p.isPhantom) return "Phantom";
        if (p.isMetaMask) return "MetaMask"; 
        if (p.name) return p.name;
        return "EVM Wallet";
    }

    getEVMProviders() {
        if (window.ethereum?.providers && Array.isArray(window.ethereum.providers)) {
            return window.ethereum.providers;
        }
        if (window.ethereum) {
            return [window.ethereum];
        }
        return [];
    }

    async attachProviderListeners(timeoutMs = 3000) {
        if (!window.ethereum) {
            const start = Date.now();
            while (!window.ethereum && (Date.now() - start) < timeoutMs) {
                await new Promise(r => setTimeout(r, 100));
            }
            if (!window.ethereum) return;
        }

        const providers = this.getEVMProviders();
        providers.forEach(p => {
            if (p && p.on) {
                p.on('accountsChanged', (accounts) => this.handleAccountsChanged(accounts));
                p.on('chainChanged', (chainId) => {
                    window.location.reload();
                });
            }
        });
    }

    handleConnectButtonClick() {
        if (this.userAddress) {
            this.disconnectWallet();
        } else {
            this.showWalletPopup();
        }
    }

    showWalletPopup() {
        const popup = this.domElements.walletPopup;
        const overlay = this.domElements.popupOverlay;
        popup.innerHTML = '';
        
        let providers = this.getEVMProviders();
        if (providers.length === 0) {
            showError("No EVM-compatible wallet detected! Please install one (e.g., MetaMask).");
            return;
        }

        providers.sort((a, b) => a.isMetaMask ? -1 : b.isMetaMask ? 1 : 0);
        
        providers.forEach((p) => {
            const walletName = this.getWalletName(p);
            const btn = document.createElement('button');
            btn.textContent = `${walletName}`;
            btn.className = 'wallet-connect-btn';

            btn.addEventListener('click', async () => {
                const ethersProvider = new ethers.BrowserProvider(p);
                this.closeWalletPopup();
                await this.connectWallet(ethersProvider, p, walletName);
            });
            popup.appendChild(btn);
        });
        
        overlay.style.display = 'block';
        popup.style.display = 'block';
    }

    closeWalletPopup() {
        if (this.domElements.popupOverlay && this.domElements.walletPopup) {
            this.domElements.popupOverlay.style.display = 'none';
            this.domElements.walletPopup.style.display = 'none';
        }
    }

    async connectWallet(ethersProvider, rawProvider = null, walletName = null) {
        this.closeWalletPopup();
        this.domElements.connectButton.textContent = 'Connect Wallet';
        let finalError = null;

        const attemptConnection = async () => {
            try {
                const accounts = rawProvider && rawProvider.request
                    ? await rawProvider.request({ method: 'eth_requestAccounts', params: [] })
                    : await ethersProvider.send("eth_requestAccounts", []);
                
                const tempUserAddress = accounts && accounts[0] ? accounts[0].toLowerCase() : null;

                if (tempUserAddress) {
                    this.provider = ethersProvider;
                    this.userAddress = tempUserAddress;
                    this.isWalletConnected = true;
                    this.walletName = walletName;

                    localStorage.setItem('userAddress', this.userAddress);
                    if (walletName) localStorage.setItem('connectedWalletName', walletName);

                    this.domElements.connectButton.textContent = `Connected: ${truncateAddress(this.userAddress)}`;

                    showLoader("ðŸ”„ Fetching data...");

                    this.readProvider = new ethers.JsonRpcProvider(NXRA_CHAIN.RPC_URL);

                    this.onWalletConnected();
                    
                    return true;
                }
                return false;
            } catch (error) {
                finalError = error;
                return false;
            }
        };

        if (await attemptConnection()) return;

        if (finalError && finalError.code === -32603) {
            console.warn("Wallet instability detected. Retrying once after 100ms...");
            await new Promise(resolve => setTimeout(resolve, 100));
            if (await attemptConnection()) return;
        }

        if (finalError) {
            console.error("Connection error (Final):", finalError);
            this.userAddress = null;
            this.domElements.connectButton.textContent = 'Connect Wallet';

            let errorMessage = "Failed to connect wallet: " + finalError.message;
            if (finalError.code === 4001) errorMessage = "Connection rejected by user.";
            else if (finalError.code === -32002) errorMessage = "Pending request. Please check your wallet's extension/pop-up.";
            else if (finalError.code === -32603) errorMessage = "Wallet not ready. Please unlock your extension and try again.";

            showError(errorMessage);
        }
    }

    async autoReconnectWallet() {
        const savedWalletName = localStorage.getItem('connectedWalletName');
        const savedAddress = localStorage.getItem('userAddress');
        if (!savedWalletName || !window.ethereum) return;

        const providers = this.getEVMProviders();
        let chosen = providers.find(pr => this.getWalletName(pr) === savedWalletName) || providers[0];
        if (!chosen) return;

        try {
            const accounts = chosen.request
                ? await chosen.request({ method: 'eth_accounts' })
                : (await new ethers.BrowserProvider(chosen).send('eth_accounts', []));
            
            if (!accounts || accounts.length === 0) {
                localStorage.removeItem('userAddress');
                localStorage.removeItem('connectedWalletName');
                return;
            }

            this.userAddress = accounts[0].toLowerCase();
            this.provider = new ethers.BrowserProvider(chosen);
            this.isWalletConnected = true;
            this.walletName = savedWalletName;
            this.readProvider = new ethers.JsonRpcProvider(NXRA_CHAIN.RPC_URL);

            if (this.domElements.connectButton) {
                this.domElements.connectButton.textContent = `Connected: ${truncateAddress(this.userAddress)}`;
            }

            this.onWalletConnected();
            console.log("Wallet auto-reconnected:", this.userAddress);
        } catch (err) {
            console.error("Auto reconnect failed:", err);
            localStorage.removeItem('userAddress');
            localStorage.removeItem('connectedWalletName');
        }
    }

    async handleAccountsChanged(accounts) {
        console.log("ACCOUNTS CHANGED EVENT FIRED. New accounts:", accounts);

        if (accounts.length === 0) {
            this.disconnectWallet();
        } else {
            const newAddress = accounts[0].toLowerCase();
            this.userAddress = newAddress;
            localStorage.setItem('userAddress', this.userAddress);

            if (window.ethereum) this.provider = new ethers.BrowserProvider(window.ethereum);

            this.onWalletConnected();
        }
    }

    disconnectWallet() {
        this.isWalletConnected = false;
        this.userAddress = null;
        this.provider = null;
        this.currentChainIdDisplay = "Not Connected";
        this.walletName = null;

        const totalRecipientsEl = document.getElementById('totalRecipients');
        const totalAmountEl = document.getElementById('totalAmount');
        const summarySymbolEl = document.getElementById('summaryTokenSymbol');

        if (totalRecipientsEl) totalRecipientsEl.textContent = '-';
        if (totalAmountEl) {
            totalAmountEl.textContent = '-';
            totalAmountEl.classList.remove('total-over');
        }
        if (summarySymbolEl) {
            summarySymbolEl.classList.remove('total-over');
        }

        localStorage.removeItem('userAddress');
        localStorage.removeItem('connectedWalletName');

        if (typeof multisender !== 'undefined') {
            multisender.updateMultiSenderUI(null);
        }

        this.onWalletDisconnected();
    }

    onWalletConnected() {
        console.log("Wallet connected:", this.userAddress);
        
        this.updateUI();
        
        if (typeof multisender !== 'undefined') {
            multisender.updateMultiSenderUI(this.userAddress);
        }

        hideLoader();
    }

    onWalletDisconnected() {
        console.log("Wallet disconnected");
        this.updateUI();
    }

    updateUI() {
        if (this.domElements.connectButton) {
            if (this.userAddress) {
                this.domElements.connectButton.textContent = 'Connected: ' + truncateAddress(this.userAddress);
                this.domElements.connectButton.classList.add('connected');
                this.domElements.connectButton.title = this.userAddress;
            } else {
                this.domElements.connectButton.textContent = 'Connect Wallet';
                this.domElements.connectButton.classList.remove('connected');
                this.domElements.connectButton.title = '';
            }
        }
    }

    getUserAddress() {
        return this.userAddress;
    }

    getProvider() {
        return this.provider;
    }

    getReadProvider() {
        return this.readProvider;
    }

    isConnected() {
        return this.isWalletConnected;
    }

    getChainId() {
        return this.currentChainIdDisplay;
    }
}

// ===== MULTISENDER CLASS =====
class Multisender {
    constructor() {
        this.multisendSelectedTokenDecimals = 18;
        this.multisendSelectedTokenBalanceWei = 0n;
        this.multisendSelectedTokenSymbol = 'NXRA';
        this.balanceRefreshInterval = null;
        this.currentTokenAddress = null;
        this.setupEventListeners();
        this.setupBalancePolling();
    }

    setupEventListeners() {
        const recipientsInputEl = document.getElementById('recipientsInput');
        const tokenSelectEl = document.getElementById('tokenSelect');
        
        if (recipientsInputEl) {
            recipientsInputEl.addEventListener('input', () => this.parseRecipientsInput());
            recipientsInputEl.addEventListener('blur', () => this.parseRecipientsInput());
        }
        
        if (tokenSelectEl) {
            tokenSelectEl.addEventListener('change', () => {
                this.parseRecipientsInput();
                this.currentTokenAddress = tokenSelectEl.value;
            });
        }

        document.getElementById('sendBatchButton')?.addEventListener('click', async (e) => {
            e.preventDefault();
            const allowed = await verifyInkyBalance();
            if (allowed) {
                await this.sendBatchSingleTx();
            }
        });
    }

    setupBalancePolling() {
        if (this.balanceRefreshInterval) {
            clearInterval(this.balanceRefreshInterval);
        }
        
        this.balanceRefreshInterval = setInterval(() => {
            if (walletManager.isConnected() && this.currentTokenAddress) {
                this.refreshCurrentTokenBalance();
            }
        }, 10000);
    }

    async refreshCurrentTokenBalance() {
        const select = document.getElementById('tokenSelect');
        const balanceEl = document.getElementById('availableTokenBalance');
        
        if (!select || !walletManager.isConnected() || select.selectedIndex === -1) return;
        
        const selectedOption = select.options[select.selectedIndex];
        if (!selectedOption || !selectedOption.dataset.balance) return;
        
        const tokenAddress = selectedOption.value;
        const decimals = parseInt(selectedOption.dataset.decimals);
        const symbol = selectedOption.dataset.symbol;
        
        try {
            let newBalance;
            
            if (tokenAddress === 'native') {
                newBalance = await getNativeBalance(walletManager.getUserAddress());
            } else {
                const tokenContract = new ethers.Contract(tokenAddress, 
                    ["function balanceOf(address) view returns (uint256)"], 
                    walletManager.getReadProvider()
                );
                newBalance = await tokenContract.balanceOf(walletManager.getUserAddress());
            }
            
            const currentBalance = BigInt(selectedOption.dataset.balance);
            if (newBalance !== currentBalance) {
                console.log(`ðŸ”„ Balance updated: ${ethers.formatUnits(newBalance, decimals)} ${symbol}`);
                
                selectedOption.dataset.balance = newBalance.toString();
                
                this.updateSelectedToken(newBalance, decimals, symbol);
                
                const formattedBalance = Number(newBalance) / Math.pow(10, decimals);
                balanceEl.textContent = formattedBalance.toLocaleString(undefined, {
                    maximumFractionDigits: 6
                });
                
                this.parseRecipientsInput();
            }
            
        } catch (error) {
            console.error("Error refreshing balance:", error);
        }
    }

    onWalletStateChanged() {
        this.setupBalancePolling();
    }

    async updateMultiSenderUI(address) {
        const select = document.getElementById('tokenSelect');
        const balanceEl = document.getElementById('availableTokenBalance');
        const symbolEl = document.getElementById('availableTokenSymbol');

        if (!address) {
            select.innerHTML = '<option value="">Connect wallet to load tokens</option>';
            balanceEl.textContent = '-';
            symbolEl.textContent = 'tNXRA';
            document.getElementById('summaryTokenSymbol').textContent = 'tNXRA';
            
            this.multisendSelectedTokenBalanceWei = 0n;
            this.multisendSelectedTokenDecimals = 18;
            this.multisendSelectedTokenSymbol = 'NXRA';
            this.currentTokenAddress = null;
            
            const recipientsInput = document.getElementById('recipientsInput');
            if (recipientsInput) {
                recipientsInput.value = '';
                recipientsInput.classList.remove('invalid');
            }
            
            const totalRecipientsEl = document.getElementById('totalRecipients');
            const totalAmountEl = document.getElementById('totalAmount');
            const summarySymbolEl = document.getElementById('summaryTokenSymbol');
            
            if (totalRecipientsEl) totalRecipientsEl.textContent = '-';
            if (totalAmountEl) {
                totalAmountEl.textContent = '-';
                totalAmountEl.classList.remove('total-over');
            }
            if (summarySymbolEl) {
                summarySymbolEl.classList.remove('total-over');
            }
            
            const errorEl = document.getElementById('multiSendError');
            if (errorEl) {
                errorEl.style.display = 'none';
                errorEl.textContent = '';
            }
            
            if (this.balanceRefreshInterval) {
                clearInterval(this.balanceRefreshInterval);
                this.balanceRefreshInterval = null;
            }
            
            return;
        }
        try {
            const [rawTokenList, nativeBalance] = await Promise.all([
                fetchTokenList(address),
                getNativeBalance(address)
            ]);

            const finalTokenMap = new Map();
            rawTokenList.forEach(token => {
                const addr = token.contractAddress?.toLowerCase();
                if (addr && addr.startsWith("0x")) {
                    if (!finalTokenMap.has(addr)) {
                        finalTokenMap.set(addr, token);
                    }
                }
            });

            const nativeTokenValue = "native";
            const tNxraEntry = {
                contractAddress: nativeTokenValue,
                symbol: "tNXRA",
                balance: nativeBalance,
                decimals: 18
            };
            finalTokenMap.set(nativeTokenValue, tNxraEntry);

            const seenKeys = new Set();
            let finalTokenList = Array.from(finalTokenMap.values()).filter(token => {
                const key = token.symbol.toUpperCase().trim() + "-" + token.contractAddress.toLowerCase();
                if (seenKeys.has(key)) return false;
                seenKeys.add(key);
                return true;
            });

            finalTokenList.sort((a, b) => {
                if (a.contractAddress === nativeTokenValue) return -1;
                if (b.contractAddress === nativeTokenValue) return 1;
                return 0;
            });

            select.innerHTML = '';
            finalTokenList.forEach(token => {
                if (BigInt(token.balance) > 0n) {
                    const option = document.createElement('option');
                    option.value = token.contractAddress;
                    option.textContent = token.symbol;
                    option.dataset.balance = token.balance.toString();
                    option.dataset.decimals = token.decimals.toString();
                    option.dataset.symbol = token.symbol;
                    select.appendChild(option);
                }
            });

            if (select.options.length === 0) {
                select.innerHTML = '<option value="">No tokens with balance found</option>';
            }

            const newHandler = () => {
                const selectedOption = cleanSelect.options[cleanSelect.selectedIndex];
                if (selectedOption && selectedOption.dataset.balance) {
                    const balanceRaw = BigInt(selectedOption.dataset.balance);
                    const decimals = parseInt(selectedOption.dataset.decimals);
                    const symbol = selectedOption.dataset.symbol;

                    this.updateSelectedToken(balanceRaw, decimals, symbol);
                    this.currentTokenAddress = selectedOption.value;

                    const formattedBalance = Number(balanceRaw) / Math.pow(10, decimals);
                    balanceEl.textContent = formattedBalance.toLocaleString(undefined, {
                        maximumFractionDigits: 6
                    });
                    symbolEl.textContent = symbol;
                    document.getElementById('summaryTokenSymbol').textContent = symbol;

                    this.parseRecipientsInput();
                }
            };

            const cleanSelect = select.cloneNode(true);
            if (select.parentNode) {
                select.parentNode.replaceChild(cleanSelect, select);
            } else {
                console.warn("âš ï¸ tokenSelect parentNode not found");
                return;
            }

            cleanSelect.addEventListener('change', newHandler);

            if (cleanSelect.options.length > 0) {
                cleanSelect.selectedIndex = 0;
                cleanSelect.dispatchEvent(new Event('change'));
                this.setupBalancePolling();
            }

        } catch (error) {
            console.error("Critical error in updateMultiSenderUI:", error);
            showError("An error occurred while loading token balances. Check the console.");
        } finally {
            hideLoader();
        }
    }

    decimalToBigInt(amountStr, decimals = 18) {
        const s = String(amountStr).trim();
        const m = s.match(/^(\d*)(?:\.(\d*))?$/);
        if (!m) throw new Error('invalid-format');
        const whole = m[1] || '0';
        let frac = m[2] || '';
        if (frac.length > decimals) throw new Error('too-many-decimals');
        const fracPadded = frac.padEnd(decimals, '0');
        const combined = whole + fracPadded;
        const cleaned = combined.replace(/^0+(?=\d)/, '') || '0';
        return BigInt(cleaned);
    }

    formatBigIntToDecimal(bn, decimals = 18, maxFractionDisplay = 6) {
        const isNeg = bn < 0n;
        const abs = isNeg ? -bn : bn;
        const s = abs.toString().padStart(decimals + 1, '0');
        const intPart = s.slice(0, s.length - decimals);
        let fracPart = s.slice(-decimals).replace(/0+$/, '');
        if (fracPart.length > maxFractionDisplay) fracPart = fracPart.slice(0, maxFractionDisplay);
        const out = fracPart ? `${intPart}.${fracPart}` : intPart;
        return (isNeg ? '-' : '') + out;
    }

    parseRecipientsInput() {
        const ta = document.getElementById('recipientsInput');
        const totalRecipientsEl = document.getElementById('totalRecipients');
        const totalAmountEl = document.getElementById('totalAmount');
        const summarySymbolEl = document.getElementById('summaryTokenSymbol');
        const errorEl = document.getElementById('multiSendError');

        if (!walletManager.isConnected()) {
            totalRecipientsEl.textContent = '-';
            totalAmountEl.textContent = '-';
            totalAmountEl.classList.remove('total-over');
            summarySymbolEl.classList.remove('total-over');
            return;
        }

        if (!ta || !totalRecipientsEl || !totalAmountEl) return;

        const raw = ta.value;
        const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);

        let totalRecipients = 0;
        let totalAmountWei = 0n;
        let invalidFound = false;
        const problems = [];
        const parsedRecipients = []; 

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const commaIndex = line.indexOf(',');
            if (commaIndex === -1) {
                invalidFound = true;
                problems.push(`Row ${i+1}: separating comma is missing.`);
                continue;
            }
            const addr = line.slice(0, commaIndex).trim();
            let amountStr = line.slice(commaIndex + 1).trim();

            if (amountStr.startsWith('.')) amountStr = '0' + amountStr;

            if (!ethers.isAddress(addr)) {
                invalidFound = true;
                problems.push(`Row ${i+1}: invalid address (${addr})`);
                continue;
            }

            if (!/^(\d+|\d*\.\d+)$/.test(amountStr)) {
                invalidFound = true;
                problems.push(`Row ${i+1}: invalid amount ("${amountStr}")`);
                continue;
            }

            try {
                const amountWei = this.decimalToBigInt(amountStr, this.multisendSelectedTokenDecimals);
                totalAmountWei += amountWei;
                totalRecipients++;
                parsedRecipients.push({ address: addr, amountWei: amountWei });
            } catch (e) {
                invalidFound = true;
                if (e.message === 'too-many-decimals') {
                    problems.push(`Row ${i+1}: too many decimals (max ${this.multisendSelectedTokenDecimals})`);
                } else {
                    problems.push(`Row ${i+1}: error while parsing the amount`);
                }
                continue;
            }
        }

        totalRecipientsEl.textContent = totalRecipients;

        const totalAmountFormatted = this.formatBigIntToDecimal(totalAmountWei, this.multisendSelectedTokenDecimals, 6);
        totalAmountEl.textContent = totalAmountFormatted;
        summarySymbolEl.textContent = this.multisendSelectedTokenSymbol;

        if (invalidFound) {
            ta.classList.add('invalid');
            errorEl.style.display = 'block';
            errorEl.textContent = problems.slice(0,3).join(' â€¢ ') + (problems.length > 3 ? ` (+${problems.length-3} others)` : '');
        } else {
            ta.classList.remove('invalid');
            errorEl.style.display = 'none';
            errorEl.textContent = '';
        }

        if (totalAmountWei > this.multisendSelectedTokenBalanceWei) {
            totalAmountEl.classList.add('total-over');
            summarySymbolEl.classList.add('total-over');
        } else {
            totalAmountEl.classList.remove('total-over');
            summarySymbolEl.classList.remove('total-over');
        }

        return {
            totalRecipients,
            totalAmountWei,
            invalidFound,
            problems,
            parsedRecipients 
        };
    }

    async sendBatchSingleTx() {
        const sendButton = document.getElementById("sendBatchButton");

        if (sendButton) {
            if (sendButton.disabled) {
                console.log("Prevented double click.");
                return;
            }
            sendButton.disabled = true;
            sendButton.classList.add("disabled");
            sendButton.textContent = "Processing...";
        }

        try {
            if (!walletManager.isConnected()) {
                showError("Wallet not connected.");
                return;
            }

            const res = this.parseRecipientsInput(); 
            if (!res || res.invalidFound) {
                showError("Invalid input: Please fix invalid recipient lines.");
                return;
            }

            const recipients = res.parsedRecipients; 
            const totalAmountWei = res.totalAmountWei; 

            if (recipients.length === 0) { 
                showError("No recipients to send."); 
                return; 
            }

            if (totalAmountWei > this.multisendSelectedTokenBalanceWei) { 
                showError(`Insufficient balance. Required: ${ethers.formatUnits(totalAmountWei, this.multisendSelectedTokenDecimals)} ${this.multisendSelectedTokenSymbol}.`); 
                return; 
            }

            const addresses = recipients.map(r => r.address);
            const amounts = recipients.map(r => r.amountWei); 

            const tokenSelect = document.getElementById('tokenSelect');
            const selectedToken = tokenSelect.value;
            
            let tx;

            const contractAddress = "0x3f9c8E5df3DeEf77A8F8994f25FE23f8968e8C62";
            const provider = new ethers.BrowserProvider(window.ethereum);
            const signer = await provider.getSigner();
            const multisendContract = new ethers.Contract(contractAddress, MULTISEND_ABI, signer); 
            const userAddress = await signer.getAddress(); 
            
            console.log("Preparing transaction(s)... Please check your wallet.");

            if (selectedToken === 'native') {
                showLoader("â³ Waiting for native batch confirmation...");
                tx = await multisendContract.multisendNative(
                    addresses,
                    amounts,
                    { value: totalAmountWei }
                );
                console.log(`Native tokens batch sent! Hash: ${tx.hash}`);
            } else {
                const tokenAddress = selectedToken; 
                const ERC20_ABI = [
                    "function approve(address spender, uint256 amount) returns (bool)",
                    "function allowance(address owner, address spender) view returns (uint256)"
                ];
                
                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
                const spenderAddress = contractAddress; 

                let currentAllowance = 0n;
                try {
                    currentAllowance = await tokenContract.allowance(userAddress, spenderAddress);
                } catch (e) {
                    showError("This token does not support allowance/approve. Cannot multisend.");
                    return;
                }

                if (currentAllowance < totalAmountWei) {
                    console.log(`Approval required for ${this.multisendSelectedTokenSymbol}.`);
                    showLoader("â³ Waiting for approval...");
                    const approveTx = await tokenContract.approve(spenderAddress, totalAmountWei);
                    await approveTx.wait();
                    console.log("Approval confirmed.");
                } else {
                    console.log("Existing approval is sufficient.");
                }

                showLoader("â³ Waiting for batch confirmation...");
                tx = await multisendContract.multisendERC20(
                    tokenAddress,
                    addresses,
                    amounts
                );
                console.log(`${this.multisendSelectedTokenSymbol} batch sent! Hash: ${tx.hash}`);
            }

            const receipt = await tx.wait();
            if (receipt.status === 1) {
                console.log(`Batch transfer successful! Tx: ${receipt.hash}`);
                showLoader('âœ… Batch sent successfully!');
                await new Promise(resolve => setTimeout(resolve, 2500));
                
                await this.refreshCurrentTokenBalance();
            } else {
                showError(`Transaction failed on-chain: ${receipt.hash}`);
            }

        } catch (error) {
            let errorMessage = "Transaction failed: Unknown issue.";
            if (error.code === 'ACTION_REJECTED') {
                errorMessage = "Transaction rejected by user.";
            } else if (error.message) {
                const reasonMatch = error.message.match(/revert reason="(.*?)"/);
                if (reasonMatch && reasonMatch[1]) {
                    errorMessage = `Transaction failed (Revert): ${reasonMatch[1]}`;
                } else if (error.data && error.data.message) {
                    errorMessage = `Transaction failed: ${error.data.message}`;
                } else {
                    errorMessage = `Transaction failed: ${error.message}`;
                }
            }
            showError(errorMessage);
            console.error("Full error details:", error);
        } finally {
            hideLoader();

            if (sendButton) {
                sendButton.disabled = false;
                sendButton.classList.remove("disabled");
                sendButton.textContent = "Send Batch";
            }
        }
    }

    updateSelectedToken(balanceRaw, decimals, symbol) {
        this.multisendSelectedTokenBalanceWei = BigInt(balanceRaw);
        this.multisendSelectedTokenDecimals = decimals;
        this.multisendSelectedTokenSymbol = symbol;
    }
}

// ===== RISK ANALYZER CLASS =====
class RiskAnalyzer {
    constructor() {
        this.analyzedTokens = new Map();
        this.domElements = {};
        this.cacheDOMElements();
        this.setupModalListeners();
        this.injectCSS();
    }

    injectCSS() {
        const style = document.createElement('style');
        style.textContent = `
            .status-eligible {
                color: #00FA9A !important;
                font-weight: 600;
            }
            .status-ineligible {
                color: #FF4500 !important;
                font-weight: 600;
            }
            .status-loading {
                color: #87CEEB !important;
                font-weight: 600;
            }
            .risk-status {
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 14px;
            }
        `;
        document.head.appendChild(style);
    }

    cacheDOMElements() {
        this.domElements.tokenAddressInput = document.getElementById('tokenAddressInput');
        this.domElements.analyzeTokenButton = document.getElementById('analyzeTokenButton');
        this.domElements.riskResults = document.getElementById('riskResults');
        this.domElements.centralisedControlStatus = document.getElementById('centralisedControlStatus');
        this.domElements.mintableStatus = document.getElementById('mintableStatus');
        this.domElements.honeypotStatus = document.getElementById('honeypotStatus');
        this.domElements.liquidityStatus = document.getElementById('liquidityStatus');
        this.domElements.rugpullStatus = document.getElementById('rugpullStatus');
    }

    setupModalListeners() {
        document.getElementById('closeHoneypotModal')?.addEventListener('click', () => {
            document.getElementById('honeypotModal').style.display = 'none';
        });
        
        window.addEventListener('click', (e) => {
            const modal = document.getElementById('honeypotModal');
            if(e.target === modal) modal.style.display = 'none';
        });
    }

    async analyzeToken() {
        if (!this.domElements.tokenAddressInput) return;
        const tokenAddress = this.domElements.tokenAddressInput.value.trim();

        if (!ethers.isAddress(tokenAddress)) {
            showError("Invalid token address format. Please enter a valid 0x address.");
            return;
        }

        try {
            const code = await walletManager.getProvider().getCode(tokenAddress);
            if (!code || code === "0x") {
                showError("This address is not a NXRA Chain smart contract. Please enter a valid contract address.");
                return;
            }
        } catch (e) {
            console.error("Error checking contract code:", e);
            showError("Unable to verify if the address is a smart contract. Check console for details.");
            return;
        }

        showLoader("ðŸ” Analysis in progress...");
        this.resetRiskResults();

        try {
            const [centralisedResult, mintableResult, honeypotResult] = await Promise.all([
                this.checkCentralisedControl(tokenAddress),
                this.checkMintable(tokenAddress),
                this.checkHoneypotRisk(tokenAddress)
            ]);

            this.setRiskStatus(this.domElements.centralisedControlStatus, centralisedResult.detail);
            this.setRiskStatus(this.domElements.mintableStatus, mintableResult);
            this.renderHoneypotStatus(honeypotResult);
            
            this.setRiskStatus(this.domElements.liquidityStatus, "Coming Soon");
            this.setRiskStatus(this.domElements.rugpullStatus, "Coming Soon");

            this.analyzedTokens.set(tokenAddress, {
                centralised: centralisedResult,
                mintable: mintableResult,
                honeypot: honeypotResult,
                timestamp: Date.now()
            });

        } catch (globalError) {
            console.error("Token analysis failed with a critical error:", globalError);
            showError("Analysis failed with a critical error. Check console for details.");
            
            this.setRiskStatus(this.domElements.centralisedControlStatus, "âŒ Analysis Error");
            this.setRiskStatus(this.domElements.mintableStatus, "âŒ Analysis Error");
            this.setRiskStatus(this.domElements.honeypotStatus, "âŒ Analysis Error");
        } finally {
            hideLoader();
        }
    }

    resetRiskResults() {
        this.setRiskStatus(this.domElements.centralisedControlStatus, "-");
        this.setRiskStatus(this.domElements.mintableStatus, "-");
        this.setRiskStatus(this.domElements.honeypotStatus, "-");
        this.setRiskStatus(this.domElements.liquidityStatus, "-");
        this.setRiskStatus(this.domElements.rugpullStatus, "-");
        
        this.domElements.riskResults.style.display = 'block';
    }

    setRiskStatus(element, statusText) {
        if (!element) return;
        element.textContent = statusText;
        
        element.classList.remove('status-eligible', 'status-ineligible', 'status-loading', 'risk-status');
        element.classList.add('risk-status');
        
        if (statusText.includes("âœ…") || statusText.includes("No centralized control") || statusText.includes("No mint function") || statusText.includes("Low Risk")) {
            element.classList.add('status-eligible');
        } 
        else if (statusText.includes("âŒ") || statusText.includes("Centralized control detected") || statusText.includes("Mint function detected") || statusText.includes("High Risk")) {
            element.classList.add('status-ineligible');
        }
        else if (statusText.includes("âš ï¸") || statusText.includes("Medium Risk")) {
            element.classList.add('status-loading');
        }
    }

    async checkCentralisedControl(tokenAddress) {
        if (!walletManager.getReadProvider()) return { status: false, detail: "âš ï¸ Unable to access provider" };
        
        const OWNER_CHECK_ABI = ["function owner() view returns (address)"];
        try {
            const contract = new ethers.Contract(tokenAddress, OWNER_CHECK_ABI, walletManager.getReadProvider());
            const ownerAddress = await contract.owner.staticCall();

            if (ethers.isAddress(ownerAddress)) {
                if (ownerAddress === ethers.ZeroAddress) {
                    return { 
                        status: false, 
                        detail: "âœ… No centralized control (ownership renounced)"
                    };
                } else {
                    return { 
                        status: true, 
                        detail: `âŒ Centralized control detected (Owner: ${truncateAddress(ownerAddress)})`
                    };
                }
            }
        } catch (e) {
            return { 
                status: false, 
                detail: "âœ… No owner() function â†’ likely decentralized"
            };
        }

        return { 
            status: false, 
            detail: "âš ï¸ Unknown error during centralized control check"
        };
    }

    async checkMintable(tokenAddress) {
        if (!walletManager.getReadProvider()) return "âš ï¸ Unable to access provider";

        const SIMULATED_CALLER = "0x1111111111111111111111111111111111111111";
        const SIMPLE_MINT_SELECTOR = "40c10f19"; 

        const MINT_FUNCTION_SIGNATURES = [
            "function mint(address to, uint256 amount) returns (bool)",
            "function mint(uint256 amount) public"
        ];
        let bytecode = "";

        for (const signature of MINT_FUNCTION_SIGNATURES) {
            try {
                const MINT_ABI = [signature];
                const contract = new ethers.Contract(tokenAddress, MINT_ABI, walletManager.getReadProvider());
                const mintFunction = contract.getFunction('mint');
                const args = signature.includes('address') 
                    ? [ethers.ZeroAddress, 1] 
                    : [1];
                const options = { from: SIMULATED_CALLER };
                await mintFunction.staticCall(...args, options);

                return "âŒ Mint function detected";

            } catch(e) {
                const errorMessage = e.toString().toLowerCase();
                if (errorMessage.includes("owner") || errorMessage.includes("zero address") || errorMessage.includes("not authorized")) {
                    return "âŒ Mint function detected";
                }

                if (signature.includes('uint256') && (errorMessage.includes("revert") || errorMessage.includes("execution reverted"))) {
                    if (bytecode === "") {
                        const bytecodeWith0x = await walletManager.getReadProvider().getCode(tokenAddress);
                        bytecode = bytecodeWith0x.substring(2).toLowerCase();
                    }

                    if (bytecode.includes(SIMPLE_MINT_SELECTOR)) {
                        return "âŒ Mint function detected";
                    }
                }
            }
        }

        return "âœ… No mint function";
    }

    async checkHoneypotRisk(tokenAddress) {
        if (!walletManager.getReadProvider()) return { status: 'â“ Unknown (Provider not connected)', selectors: [] };
        
        try {
            const ownershipStatus = await this.checkCentralisedControl(tokenAddress);
            const isOwnershipRenounced = ownershipStatus.detail.includes("renounced") || 
                                       ownershipStatus.detail.includes("No owner() function");

            const abi = await this.fetchABIFromExplorer(tokenAddress);
            
            let detectedFunctions = [];
            let methodUsed = 'ABI';
            
            if (abi && abi.length > 0) {
                detectedFunctions = this.checkRiskyFunctionsInABI(abi, isOwnershipRenounced);
            } else {
                methodUsed = 'Function Probing';
                detectedFunctions = await this.checkRiskyFunctionsViaRevert(tokenAddress, isOwnershipRenounced);
            }
            
            if (detectedFunctions.length > 0) {
                return { 
                    status: 'âš ï¸ Medium Risk (Control Functions Detected)', 
                    selectors: detectedFunctions,
                    method: methodUsed
                };
            }
            
            return { 
                status: 'âœ… Low Risk (No Control Functions)', 
                selectors: [],
                method: methodUsed
            };
            
        } catch (e) {
            console.error("[Honeypot Check] Erreur:", e);
            return { status: 'â“ Unknown (Analysis Error)', selectors: [] };
        }
    }

    async fetchABIFromExplorer(tokenAddress) {
        const url = `${NXRA_CHAIN.API_BASE_URL}api?module=contract&action=getabi&address=${tokenAddress}`;
        
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.status === '1' && data.result && data.result !== "Contract source code not verified") {
                return JSON.parse(data.result);
            } else {
                return null;
            }
        } catch (error) {
            console.error("[ABI Fetch] Erreur:", error);
            return null;
        }
    }

    checkRiskyFunctionsInABI(abi, isOwnershipRenounced = false) {
        const detectedFunctions = [];
        
        abi.forEach(item => {
            if (item.type === 'function') {
                const functionName = item.name;
                
                if (isOwnershipRenounced && functionName === 'transferOwnership') {
                    console.log("â„¹ï¸ transferOwnership ignorÃ© car ownership renoncÃ©");
                    return;
                }
                
                if (HONEYPOT_FUNCTIONS[functionName]) {
                    detectedFunctions.push(functionName);
                }
            }
        });
        
        return detectedFunctions;
    }

    async checkRiskyFunctionsViaRevert(tokenAddress, isOwnershipRenounced = false) {
        const HONEYPOT_FUNCTION_SIGNATURES = [
            "function setMaxTransferAmount(uint256 _amount)",
            "function setMaxSellAmount(uint256 _amount)",
            "function setBlackList(address _user, bool _status)",
            "function setTaxFeePercent(uint256 _fee)",
            "function transferOwnership(address newOwner)",
            "function enableTrading(bool _enabled)",
            "function setTradingEnabled(bool _enabled)",
            "function setTradingStatus(bool _status)",
            "function updateOwner(address newOwner)",
            "function setMaxTxAmount(uint256 _amount)",
            "function setMaxWallet(uint256 _amount)",
            "function setWhitelist(address _user, bool _status)",
            "function excludeFromFee(address _user)",
            "function includeInFee(address _user)",
            "function setSwapAndLiquifyEnabled(bool _enabled)"
        ];

        const detectedFunctions = [];

        for (const signature of HONEYPOT_FUNCTION_SIGNATURES) {
            const functionName = signature.split('function ')[1].split('(')[0];
            
            if (isOwnershipRenounced && functionName === 'transferOwnership') {
                console.log("â„¹ï¸ transferOwnership ignorÃ© car ownership renoncÃ©");
                continue;
            }
            
            try {
                const ABI = [signature];
                const contract = new ethers.Contract(tokenAddress, ABI, walletManager.getReadProvider());
                const functionObj = contract.getFunction(functionName);
                const args = this.generateRealisticArgs(signature);
                
                await functionObj.staticCall(...args);
                detectedFunctions.push(functionName);

            } catch(e) {
                const errorMessage = e.toString().toLowerCase();
                const existenceIndicators = [
                    "owner", "onlyowner", "unauthorized", "not authorized",
                    "caller is not", "access denied", "restricted"
                ];
                
                const falsePositiveIndicators = [
                    "cannot estimate gas", "gas required", "out of gas",
                    "missing revert data", "invalid opcode", "end of input",
                    "array length", "data out of bounds", "overflow",
                    "invalid big number", "underflow", "hex data"
                ];

                let isFalsePositive = false;
                for (const fpIndicator of falsePositiveIndicators) {
                    if (errorMessage.includes(fpIndicator)) {
                        isFalsePositive = true;
                        break;
                    }
                }
                
                if (isFalsePositive) continue;

                let detected = false;
                for (const indicator of existenceIndicators) {
                    if (errorMessage.includes(indicator)) {
                        const revertIndex = errorMessage.indexOf("revert");
                        const indicatorIndex = errorMessage.indexOf(indicator);
                        
                        if (revertIndex !== -1 && indicatorIndex > revertIndex) {
                            detectedFunctions.push(functionName);
                            detected = true;
                            break;
                        }
                    }
                }
            }
            
            await new Promise(resolve => setTimeout(resolve, 300));
        }

        return detectedFunctions;
    }

    generateRealisticArgs(signature) {
        if (signature.includes('address,bool')) {
            return ["0x1111111111111111111111111111111111111111", true];
        } else if (signature.includes('uint256')) {
            return [ethers.parseUnits("1000", 18)];
        } else if (signature.includes('bool')) {
            return [true];
        } else if (signature.includes('address')) {
            return ["0x1111111111111111111111111111111111111111"];
        }
        return [];
    }

    renderHoneypotStatus(result) {
        const container = this.domElements.honeypotStatus;
        if (!container) return;
        
        container.innerHTML = '';
        
        let displayText = result.status;
        if (result.method) {
            displayText += ` (via ${result.method})`;
        }
        
        const statusText = document.createElement('span');
        statusText.textContent = displayText;
        container.appendChild(statusText);
        
        container.classList.remove('status-eligible', 'status-ineligible', 'status-loading', 'risk-status');
        container.classList.add('risk-status');
        
        if (result.status.includes('âœ…') || result.status.includes('Low Risk')) {
            container.classList.add('status-eligible');
        } 
        else if (result.status.includes('âš ï¸') || result.status.includes('Medium Risk')) {
            container.classList.add('status-loading');
        }
        else if (result.status.includes('âŒ') || result.status.includes('High Risk')) {
            container.classList.add('status-ineligible');
        }

        if (result.status.includes('Medium Risk') && result.selectors && result.selectors.length > 0) {
            const viewLink = document.createElement('a');
            viewLink.href = "#";
            viewLink.textContent = " View Details";
            viewLink.style.marginLeft = "10px";
            viewLink.style.color = "#6495ED";
            viewLink.style.cursor = "pointer";
            viewLink.style.textDecoration = "underline";
            viewLink.addEventListener('click', (e) => {
                e.preventDefault();
                this.showHoneypotModal(result.selectors);
            });
            container.appendChild(viewLink);
        }
    }

    showHoneypotModal(detectedFunctions) {
        const modal = document.getElementById('honeypotModal');
        const detailsList = document.getElementById('honeypotDetailsList');
        
        if (!modal || !detailsList) return;
        
        detailsList.innerHTML = '';

        detectedFunctions.forEach(functionName => {
            const li = document.createElement('li');
            const description = HONEYPOT_FUNCTIONS[functionName] || `Function: ${functionName}`;
            li.textContent = `${functionName}: ${description}`;
            detailsList.appendChild(li);
        });
        
        modal.style.display = 'flex';
    }
}

// ===== UNIVERSAL VESTING ANALYZER CLASS =====
class UniversalVestingAnalyzer {
    constructor() {
        this.analyzedContracts = new Map();
    }

    async analyzeVesting() {
        const tokenAddressInput = document.getElementById('tokenAddressVesting');
        const vestingTableBody = document.querySelector('#vestingTable tbody');
        
        if (!tokenAddressInput || !vestingTableBody) return;
        
        const contractAddress = tokenAddressInput.value.trim();
        
        if (!ethers.isAddress(contractAddress)) {
            showError("Invalid contract address format.");
            return;
        }

        try {
            const code = await walletManager.getProvider().getCode(contractAddress);
            if (!code || code === "0x") {
                showError("This address is not a NXRA Chain smart contract. Please enter a valid contract address.");
                return;
            }
        } catch (e) {
            console.error("Error checking contract code:", e);
            showError("Unable to verify if the address is a smart contract. Check console for details.");
            return;
        }

        showLoader("ðŸ” Analysis in progress...");
        
        try {
            vestingTableBody.innerHTML = `
                <tr>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                </tr>
            `;
            
            const vestingData = await this.universalVestingAnalysis(contractAddress);
            
            if (vestingData.length === 0) {
                vestingTableBody.innerHTML = '<tr><td colspan="4" class="no-data-message">No vesting schedules found.</td></tr>';
            } else {
                this.populateVestingTable(vestingData);
            }
            
        } catch (error) {
            console.error("Vesting analysis failed:", error);
            showError("Analysis failed. Check console for details.");
        } finally {
            hideLoader();
        }
    }

    async universalVestingAnalysis(contractAddress) {
        console.log("ðŸ” UNIVERSAL VESTING ANALYSIS:", contractAddress);
        const allVestingData = [];
        
        try {
            const isERC20 = await this.isERC20TokenPermissive(contractAddress);
            console.log(`ðŸ“Š Contract type: ${isERC20 ? 'ERC20 with Vesting' : 'Pure Vesting Contract'}`);
            
            const results = await this.aggressiveFunctionAnalysis(contractAddress, isERC20);
            
            const patterns = [
                () => this.findTokenVestingPattern(contractAddress, results, isERC20),
                () => this.findPureVestingContracts(contractAddress, results, isERC20),
                () => this.findSimpleTeamVesting(results),
                () => this.findTeamWalletVesting(results),
                () => this.findSimpleVesting(results),
                () => this.findStandardVesting(results),
                () => this.findCalculatedVesting(results),
                () => this.findVestedAmountVesting(results),
                () => this.findMultiBeneficiaryVesting(contractAddress, results),
                () => this.findContractBalanceVesting(contractAddress, results)
            ];

            for (const patternFinder of patterns) {
                try {
                    const data = await patternFinder();
                    if (data && data.length > 0) {
                        allVestingData.push(...data);
                        console.log(`âœ… Found ${data.length} items with ${patternFinder.name}`);
                    }
                } catch (e) {
                    console.log(`âŒ ${patternFinder.name} failed:`, e.message);
                }
            }

        } catch (error) {
            console.error("Universal analysis failed:", error);
        }
        
        console.log(`ðŸŽ¯ Found ${allVestingData.length} vesting schedules`);
        return this.removeDuplicates(allVestingData);
    }

    async isERC20TokenPermissive(contractAddress) {
        try {
            const essentialFunctions = [
                "function totalSupply() view returns (uint256)",
                "function balanceOf(address) view returns (uint256)"
            ];
            
            let successCount = 0;
            
            for (const funcSig of essentialFunctions) {
                try {
                    const contract = new ethers.Contract(contractAddress, [funcSig], walletManager.getReadProvider());
                    const funcName = funcSig.split(' ')[1].split('(')[0];
                    await contract[funcName](contractAddress);
                    successCount++;
                } catch (e) {
                    console.log(`ERC20 check failed for ${funcSig}:`, e.message);
                }
            }
            
            return successCount >= 1;
            
        } catch (error) {
            console.log("ERC20 permissive check failed, defaulting to true:", error);
            return true;
        }
    }

    async aggressiveFunctionAnalysis(contractAddress, isERC20) {
        const functions = [
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)",
            "function name() view returns (string)",
            "function totalSupply() view returns (uint256)",
            "function balanceOf(address) view returns (uint256)",
            "function beneficiary() view returns (address)",
            "function beneficiaries(uint256) view returns (address)",
            "function recipient() view returns (address)",
            "function holder() view returns (address)",
            "function owner() view returns (address)",
            "function team() view returns (address)",
            "function teamWallet() view returns (address)",
            "function investor() view returns (address)",
            "function advisor() view returns (address)",
            "function founder() view returns (address)",
            "function treasury() view returns (address)",
            "function wallet() view returns (address)",
            "function account() view returns (address)",
            "function user() view returns (address)",
            "function receiver() view returns (address)",
            "function getBeneficiary() view returns (address)",
            "function start() view returns (uint256)",
            "function startTime() view returns (uint256)",
            "function vestingStart() view returns (uint256)",
            "function teamVestingStart() view returns (uint256)",
            "function investorVestingStart() view returns (uint256)",
            "function advisorVestingStart() view returns (uint256)",
            "function cliff() view returns (uint256)",
            "function cliffDuration() view returns (uint256)",
            "function cliffTime() view returns (uint256)",
            "function lock() view returns (uint256)",
            "function lockTime() view returns (uint256)",
            "function unlockTime() view returns (uint256)",
            "function begin() view returns (uint256)",
            "function commencement() view returns (uint256)",
            "function initialization() view returns (uint256)",
            "function duration() view returns (uint256)",
            "function vestingDuration() view returns (uint256)",
            "function teamVestingDuration() view returns (uint256)",
            "function investorVestingDuration() view returns (uint256)",
            "function advisorVestingDuration() view returns (uint256)",
            "function end() view returns (uint256)",
            "function endTime() view returns (uint256)",
            "function finish() view returns (uint256)",
            "function period() view returns (uint256)",
            "function periods() view returns (uint256)",
            "function quarters() view returns (uint256)",
            "function months() view returns (uint256)",
            "function years() view returns (uint256)",
            "function cycle() view returns (uint256)",
            "function interval() view returns (uint256)",
            "function totalVesting() view returns (uint256)",
            "function vestingAmount() view returns (uint256)",
            "function teamTotalVesting() view returns (uint256)",
            "function teamVestingAmount() view returns (uint256)",
            "function investorTotalVesting() view returns (uint256)",
            "function investorVestingAmount() view returns (uint256)",
            "function advisorTotalVesting() view returns (uint256)",
            "function advisorVestingAmount() view returns (uint256)",
            "function totalAmount() view returns (uint256)",
            "function allocated() view returns (uint256)",
            "function allocation() view returns (uint256)",
            "function grant() view returns (uint256)",
            "function amount() view returns (uint256)",
            "function total() view returns (uint256)",
            "function initialAmount() view returns (uint256)",
            "function initialAllocation() view returns (uint256)",
            "function released() view returns (uint256)",
            "function teamReleased() view returns (uint256)",
            "function investorReleased() view returns (uint256)",
            "function advisorReleased() view returns (uint256)",
            "function claimed() view returns (uint256)",
            "function teamClaimed() view returns (uint256)",
            "function investorClaimed() view returns (uint256)",
            "function advisorClaimed() view returns (uint256)",
            "function withdrawn() view returns (uint256)",
            "function distributed() view returns (uint256)",
            "function vestedAndReleased() view returns (uint256)",
            "function totalReleased() view returns (uint256)",
            "function totalClaimed() view returns (uint256)",
            "function totalWithdrawn() view returns (uint256)",
            "function vestedAmount() view returns (uint256)",
            "function vestedAmount(address) view returns (uint256)",
            "function releasable() view returns (uint256)",
            "function releasableAmount() view returns (uint256)",
            "function claimable() view returns (uint256)",
            "function claimableAmount() view returns (uint256)",
            "function withdrawable() view returns (uint256)",
            "function available() view returns (uint256)",
            "function unlocked() view returns (uint256)",
            "function vested() view returns (uint256)",
            "function vesting() view returns (uint256)",
            "function computeReleasableAmount() view returns (uint256)",
            "function calculateVested() view returns (uint256)",
            "function getReleasable() view returns (uint256)",
            "function getClaimable() view returns (uint256)",
            "function getVested() view returns (uint256)",
            "function pending() view returns (uint256)",
            "function pendingAmount() view returns (uint256)",
            "function token() view returns (address)",
            "function vestedToken() view returns (address)",
            "function vestingToken() view returns (address)",
            "function targetToken() view returns (address)",
            "function underlying() view returns (address)",
            "function asset() view returns (address)",
            "function getVestingSchedule(address) view returns (uint256,uint256,uint256,uint256)",
            "function vestingSchedules(address) view returns (uint256,uint256,uint256,uint256)",
            "function vestingInfo(address) view returns (uint256,uint256,uint256,uint256)",
            "function vestingDetails(address) view returns (uint256,uint256,uint256,uint256)",
            "function schedules(address) view returns (uint256,uint256,uint256,uint256)",
            "function info(address) view returns (uint256,uint256,uint256,uint256)",
            "function details(address) view returns (uint256,uint256,uint256,uint256)",
            "function getVesting(address) view returns (uint256,uint256,uint256,uint256)",
            "function vestingOf(address) view returns (uint256,uint256,uint256,uint256)",
            "function beneficiaries(uint256) view returns (address)",
            "function beneficiariesCount() view returns (uint256)",
            "function allBeneficiaries() view returns (address[])",
            "function getBeneficiaries() view returns (address[])",
            "function vestingScheduleCount() view returns (uint256)",
            "function totalBeneficiaries() view returns (uint256)",
            "function initialized() view returns (bool)",
            "function paused() view returns (bool)",
            "function revoked() view returns (bool)",
            "function cancelled() view returns (bool)",
            "function active() view returns (bool)",
            "function status() view returns (uint8)",
            "function stage() view returns (uint8)",
            "function phase() view returns (uint8)",
            "function computeVestedAmount(uint256) view returns (uint256)",
            "function calculateVesting(address) view returns (uint256)",
            "function getVestedPercentage() view returns (uint256)",
            "function vestedPercent() view returns (uint256)",
            "function releasedPercentage() view returns (uint256)",
            "function remainingVesting() view returns (uint256)",
            "function remainingTime() view returns (uint256)",
            "function timeUntilNextUnlock() view returns (uint256)",
            "function nextUnlock() view returns (uint256)",
            "function nextVesting() view returns (uint256)"
        ];

        const results = { isERC20 };
        
        const batchSize = 20;
        for (let i = 0; i < functions.length; i += batchSize) {
            const batch = functions.slice(i, i + batchSize);
            const promises = batch.map(funcSig => 
                this.testFunction(contractAddress, funcSig, results)
            );
            await Promise.allSettled(promises);
            
            if (i + batchSize < functions.length) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
        
        return results;
    }

    async testFunction(contractAddress, funcSig, results) {
        const funcName = funcSig.split(' ')[1].split('(')[0];
        
        try {
            const contract = new ethers.Contract(contractAddress, [funcSig], walletManager.getReadProvider());
            
            let result;
            if (funcSig.includes('balanceOf(address)')) {
                result = await contract[funcName](contractAddress);
            } else if (funcSig.includes('getVestingSchedule(address)') || 
                    funcSig.includes('vestingSchedules(address)')) {
                try {
                    const owner = results.owner || await this.getOwner(contractAddress);
                    if (owner) {
                        result = await contract[funcName](owner);
                    } else {
                        result = null;
                    }
                } catch (e) {
                    result = null;
                }
            } else {
                result = await contract[funcName]();
            }
            
            results[funcName] = result;
            
        } catch (error) {
            results[funcName] = null;
        }
    }

    async findSimpleTeamVesting(results) {
        const vestingData = [];
        if (results.team && results.teamVestingStart && results.teamVestingDuration && results.teamTotalVesting) {
            const tokenInfo = {
                symbol: results.symbol || "TOKEN", 
                decimals: results.decimals ? Number(results.decimals) : 18
            };
            
            const claimed = results.teamClaimed || results.claimed || results.teamReleased || 0n;
            
            const releasable = await this.calculateReleasable(
                Number(results.teamVestingStart), 0, Number(results.teamVestingDuration),
                claimed, results.teamTotalVesting
            );
            
            const item = await this.createVestingItem(
                results.teamTotalVesting, 
                claimed,
                Number(results.teamVestingStart), 
                Number(results.teamVestingDuration),
                0, 
                releasable, 
                results.team, 
                tokenInfo, 
                "Team Vesting",
                true
            );
            if (item) vestingData.push(item);
        }
        return vestingData;
    }

    async findTeamWalletVesting(results) {
        const vestingData = [];
        if (results.teamWallet && results.teamVestingStart && results.teamVestingDuration && results.teamTotalVesting) {
            const tokenInfo = {
                symbol: results.symbol || "TOKEN",
                decimals: results.decimals ? Number(results.decimals) : 18
            };
            
            const claimed = results.teamClaimed || results.claimed || results.teamReleased || 0n;
            
            const releasable = await this.calculateReleasable(
                Number(results.teamVestingStart), 0, Number(results.teamVestingDuration),
                claimed, results.teamTotalVesting
            );
            
            const item = await this.createVestingItem(
                results.teamTotalVesting, 
                claimed,
                Number(results.teamVestingStart), 
                Number(results.teamVestingDuration),
                0, 
                releasable, 
                results.teamWallet, 
                tokenInfo, 
                "Team Wallet Vesting",
                true
            );
            if (item) vestingData.push(item);
        }
        return vestingData;
    }

    async findSimpleVesting(results) {
        const vestingData = [];
        
        if (results.teamWallet && results.vestingStart && results.vestingDuration && results.totalVesting) {
            const tokenInfo = {
                symbol: results.symbol || "TOKEN",
                decimals: results.decimals ? Number(results.decimals) : 18
            };
            
            const claimed = results.claimed || results.teamClaimed || results.released || 0n;
            
            const releasable = await this.calculateReleasable(
                Number(results.vestingStart), 0, Number(results.vestingDuration),
                claimed, results.totalVesting
            );
            
            const item = await this.createVestingItem(
                results.totalVesting, 
                claimed,
                Number(results.vestingStart), 
                Number(results.vestingDuration),
                0, 
                releasable, 
                results.teamWallet, 
                tokenInfo, 
                "Linear Vesting",
                true
            );
            if (item) vestingData.push(item);
        }
        
        return vestingData;
    }

    async findStandardVesting(results) {
        const vestingData = [];
        if (results.beneficiary && results.start && results.duration && results.vestingAmount) {
            const tokenInfo = {
                symbol: results.symbol || "TOKEN",
                decimals: results.decimals ? Number(results.decimals) : 18
            };
            const releasable = await this.calculateReleasable(
                Number(results.start), 0, Number(results.duration),
                results.released || 0n, results.vestingAmount
            );
            const item = await this.createVestingItem(
                results.vestingAmount, 
                results.released || 0n,
                Number(results.start), 
                Number(results.duration),
                0, 
                releasable, 
                results.beneficiary, 
                tokenInfo, 
                "Standard Vesting",
                true
            );
            if (item) vestingData.push(item);
        }
        return vestingData;
    }

    async findCalculatedVesting(results) {
        const vestingData = [];
        if ((results.team || results.teamWallet) && results.start && results.duration && results.vestedAmount && results.released) {
            const tokenInfo = {
                symbol: results.symbol || "TOKEN",
                decimals: results.decimals ? Number(results.decimals) : 18
            };
            const totalAmount = results.vestedAmount + results.released;
            const releasable = results.vestedAmount - results.released;
            const item = await this.createVestingItem(
                totalAmount, 
                results.released,
                Number(results.start), 
                Number(results.duration),
                0, 
                releasable > 0n ? releasable : 0n,
                results.team || results.teamWallet, 
                tokenInfo, 
                "Calculated Vesting",
                true
            );
            if (item) vestingData.push(item);
        }
        return vestingData;
    }

    async findTokenVestingPattern(contractAddress, results, isERC20) {
        const vestingData = [];
        
        try {
            if (results.token && results.beneficiary && results.start && results.duration && !isERC20) {
                console.log("ðŸ” Detected TokenVesting pattern");
                
                let tokenInfo = { symbol: "TOKEN", decimals: 18 };
                try {
                    tokenInfo = await this.getTokenInfo(results.token);
                } catch (e) {
                    console.log("Could not get token info, using defaults");
                }
                
                let totalAmount = 0n;
                try {
                    const tokenContract = new ethers.Contract(results.token, 
                        ["function balanceOf(address) view returns (uint256)"], 
                        walletManager.getReadProvider()
                    );
                    totalAmount = await tokenContract.balanceOf(contractAddress);
                    totalAmount += (results.released || 0n);
                } catch (e) {
                    console.log("Could not get contract balance");
                }
                
                const released = results.released || 0n;
                
                let releasable = 0n;
                if (results.vestedAmount !== null && results.vestedAmount !== undefined) {
                    const vested = results.vestedAmount || 0n;
                    releasable = vested > released ? vested - released : 0n;
                } else {
                    releasable = await this.calculateReleasable(
                        Number(results.start), 0, Number(results.duration), released, totalAmount
                    );
                }
                
                const item = await this.createVestingItem(
                    totalAmount, 
                    released,
                    Number(results.start), 
                    Number(results.duration),
                    0, 
                    releasable, 
                    results.beneficiary, 
                    tokenInfo, 
                    "Token Vesting Contract",
                    true
                );
                if (item) vestingData.push(item);
            }
        } catch (error) {
            console.error("TokenVesting pattern failed:", error);
        }
        
        return vestingData;
    }

    async findPureVestingContracts(contractAddress, results, isERC20) {
        const vestingData = [];
        
        try {
            if (!isERC20 && (results.token || results.getVestingSchedule || results.vestingSchedules)) {
                console.log("ðŸ” Detected pure vesting contract, analyzing...");
                
                let tokenAddress = results.token || results.vestedToken;
                let tokenInfo = { symbol: "VESTED", decimals: 18 };
                
                if (tokenAddress && tokenAddress !== ethers.ZeroAddress) {
                    try {
                        tokenInfo = await this.getTokenInfo(tokenAddress);
                    } catch (e) {
                        console.log("âŒ Could not get token info, using defaults");
                    }
                }
                
                let beneficiary = results.beneficiary || results.recipient || results.team || results.teamWallet;
                
                if (beneficiary && beneficiary !== ethers.ZeroAddress) {
                    let totalAmount = results.totalVesting || results.vestingAmount || results.totalAmount || 0n;
                    let released = results.released || results.claimed || 0n;
                    let startTime = Number(results.start || results.vestingStart || results.teamVestingStart || 0);
                    let duration = Number(results.duration || results.vestingDuration || results.teamVestingDuration || 0);
                    
                    if (totalAmount > 0n && startTime > 0) {
                        const releasable = results.releasable || results.releasableAmount || 
                                          await this.calculateReleasable(startTime, 0, duration, released, totalAmount);
                        
                        const item = await this.createVestingItem(
                            totalAmount, 
                            released,
                            startTime, 
                            duration,
                            Number(results.cliff || 0), 
                            releasable, 
                            beneficiary, 
                            tokenInfo, 
                            "Vesting Contract",
                            true
                        );
                        if (item) vestingData.push(item);
                    }
                }
                
                if (vestingData.length === 0 && (results.getVestingSchedule !== null || results.vestingSchedules !== null)) {
                    const owner = await this.getOwner(contractAddress);
                    if (owner && owner !== ethers.ZeroAddress) {
                        const vestingItem = await this.getVestingFromMapping(contractAddress, owner, tokenInfo);
                        if (vestingItem) vestingData.push(vestingItem);
                    }
                }
            }
            
        } catch (error) {
            console.error("Pure vesting contract analysis failed:", error);
        }
        
        return vestingData;
    }

    async findVestedAmountVesting(results) {
        const vestingData = [];
        
        if (results.beneficiary && results.start && results.duration && results.vestedAmount !== null) {
            const tokenInfo = {
                symbol: results.symbol || "TOKEN",
                decimals: results.decimals ? Number(results.decimals) : 18
            };
            
            const released = results.released || 0n;
            const vested = results.vestedAmount || 0n;
            const releasable = vested > released ? vested - released : 0n;
            
            const item = await this.createVestingItem(
                vested + released,
                released,
                Number(results.start), 
                Number(results.duration),
                0, 
                releasable, 
                results.beneficiary, 
                tokenInfo, 
                "Vested Amount Vesting",
                true
            );
            if (item) vestingData.push(item);
        }
        
        return vestingData;
    }

    async findMultiBeneficiaryVesting(contractAddress, results) {
        const vestingData = [];
        return vestingData;
    }

    async findContractBalanceVesting(contractAddress, results) {
        const vestingData = [];
        try {
            const contractBalance = results.balanceOf || 0n;
            if (contractBalance > 0n) {
                const tokenInfo = {
                    symbol: results.symbol || "TOKEN",
                    decimals: results.decimals ? Number(results.decimals) : 18
                };
                let beneficiary = results.team || results.teamWallet || results.beneficiary || results.owner;
                if (!beneficiary || beneficiary === ethers.ZeroAddress) {
                    beneficiary = contractAddress;
                }
                const item = await this.createVestingItem(
                    contractBalance, 
                    0n, 
                    Math.floor(Date.now() / 1000),
                    365 * 24 * 60 * 60, 
                    0, 
                    0n, 
                    beneficiary, 
                    tokenInfo, 
                    "Contract Holdings",
                    false
                );
                if (item) vestingData.push(item);
            }
        } catch (error) {
            console.error("Contract balance vesting failed:", error);
        }
        return vestingData;
    }

    async getTokenInfo(tokenAddress) {
        const info = { symbol: "UNKNOWN", decimals: 18, name: "Unknown" };
        
        const functions = [
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)",
            "function name() view returns (string)"
        ];

        for (const funcSig of functions) {
            try {
                const contract = new ethers.Contract(tokenAddress, [funcSig], walletManager.getReadProvider());
                const funcName = funcSig.split(' ')[1].split('(')[0];
                const result = await contract[funcName]();
                
                if (funcName === 'symbol') info.symbol = result;
                else if (funcName === 'decimals') info.decimals = Number(result);
                else if (funcName === 'name') info.name = result;
            } catch (e) {
            }
        }
        
        return info;
    }

    async getOwner(contractAddress) {
        try {
            const contract = new ethers.Contract(contractAddress, 
                ["function owner() view returns (address)"], 
                walletManager.getReadProvider()
            );
            return await contract.owner();
        } catch (e) {
            return null;
        }
    }

    async getVestingFromMapping(contractAddress, beneficiary, tokenInfo) {
        try {
            try {
                const contract = new ethers.Contract(contractAddress, 
                    ["function getVestingSchedule(address) view returns (uint256,uint256,uint256,uint256)"], 
                    walletManager.getReadProvider()
                );
                const schedule = await contract.getVestingSchedule(beneficiary);
                
                if (schedule && schedule[0] > 0) {
                    const releasable = await this.calculateReleasable(
                        Number(schedule[2]), 0, Number(schedule[3]), schedule[1], schedule[0]
                    );
                    return await this.createVestingItem(
                        schedule[0], schedule[1], Number(schedule[2]), Number(schedule[3]), 
                        0, releasable, beneficiary, tokenInfo, "Vesting Schedule", true
                    );
                }
            } catch (e) {}
            
            try {
                const contract = new ethers.Contract(contractAddress, 
                    ["function vestingSchedules(address) view returns (uint256,uint256,uint256,uint256)"], 
                    walletManager.getReadProvider()
                );
                const schedule = await contract.vestingSchedules(beneficiary);
                
                if (schedule && schedule[0] > 0) {
                    const releasable = await this.calculateReleasable(
                        Number(schedule[2]), 0, Number(schedule[3]), schedule[1], schedule[0]
                    );
                    return await this.createVestingItem(
                        schedule[0], schedule[1], Number(schedule[2]), Number(schedule[3]), 
                        0, releasable, beneficiary, tokenInfo, "Vesting Schedule", true
                    );
                }
            } catch (e) {}
            
        } catch (error) {
            console.error("Get vesting from mapping failed:", error);
        }
        return null;
    }

    async createVestingItem(totalAmount, released, startTime, duration, cliff, releasableNow, beneficiary, tokenInfo, type, isLinear = false) {
        if (!totalAmount || totalAmount === 0n) return null;
        if (!beneficiary || beneficiary === ethers.ZeroAddress) return null;
        if (startTime <= 0) startTime = Math.floor(Date.now() / 1000);
        if (duration <= 0) duration = 365 * 24 * 60 * 60;

        const nextUnlock = this.calculateNextUnlock(startTime, cliff, duration, released, totalAmount, releasableNow);

        return {
            ticker: tokenInfo.symbol,
            allocated: totalAmount,
            released: released,
            remaining: totalAmount - released,
            startTime: startTime,
            duration: duration,
            cliff: cliff,
            releasableNow: releasableNow,
            nextUnlockAmount: nextUnlock.amount,
            nextUnlockTime: nextUnlock.time,
            beneficiary: beneficiary,
            decimals: tokenInfo.decimals,
            type: type,
            isLinear: isLinear
        };
    }

    calculateNextUnlock(startTime, cliff, duration, released, totalAllocated, releasableNow) {
        const currentTime = Math.floor(Date.now() / 1000);
        
        if (releasableNow > 0) {
            return { amount: 0n, time: 0 };
        }
        
        if (currentTime < startTime + cliff) {
            return { 
                amount: totalAllocated, 
                time: startTime + cliff 
            };
        }
        
        if (currentTime < startTime + duration) {
            const nextCheckTime = currentTime + 86400;
            
            if (nextCheckTime < startTime + duration) {
                const timePassed = currentTime - startTime;
                const vestedSoFar = (totalAllocated * BigInt(timePassed)) / BigInt(duration);
                const nextVested = (totalAllocated * BigInt(nextCheckTime - startTime)) / BigInt(duration);
                
                return {
                    amount: nextVested - vestedSoFar,
                    time: nextCheckTime
                };
            } else {
                return {
                    amount: totalAllocated - ((totalAllocated * BigInt(currentTime - startTime)) / BigInt(duration)),
                    time: startTime + duration
                };
            }
        }
        
        return { amount: 0n, time: 0 };
    }

    async calculateReleasable(startTime, cliff, duration, released, totalAmount) {
        const currentTime = Math.floor(Date.now() / 1000);
        if (currentTime < startTime + cliff) return 0n;
        if (currentTime >= startTime + duration) return totalAmount - released;
        const timeElapsed = BigInt(currentTime - startTime);
        const vestedAmount = (totalAmount * timeElapsed) / BigInt(duration);
        return vestedAmount > released ? vestedAmount - released : 0n;
    }

    removeDuplicates(vestingData) {
        const unique = [];
        const seen = new Set();
        
        const sortedData = [...vestingData].sort((a, b) => {
            if (a.type === "Contract Holdings" && b.type !== "Contract Holdings") return 1;
            if (a.type !== "Contract Holdings" && b.type === "Contract Holdings") return -1;
            
            const typePriority = {
                "Token Vesting Contract": 1,
                "Vesting Contract": 2, 
                "Vesting Schedule": 3,
                "Standard Vesting": 4,
                "Linear Vesting": 5,
                "Vested Amount Vesting": 6,
                "Team Vesting": 7,
                "Calculated Vesting": 8,
                "Contract Holdings": 9
            };
            
            return (typePriority[a.type] || 10) - (typePriority[b.type] || 10);
        });
        
        for (const item of sortedData) {
            const baseKey = `${item.beneficiary}-${item.allocated}-${item.startTime}`;
            
            if (item.type === "Contract Holdings") {
                const hasRealVesting = unique.some(other => 
                    other.beneficiary === item.beneficiary && 
                    !other.type.includes("Holdings")
                );
                if (hasRealVesting) continue;
            }
            
            if (!seen.has(baseKey)) {
                seen.add(baseKey);
                unique.push(item);
            }
        }
        
        return unique;
    }

    populateVestingTable(vestingData) {
        const tbody = document.querySelector('#vestingTable tbody');
        if (!tbody) return;
        
        tbody.innerHTML = '';
        
        if (vestingData.length === 0) {
            tbody.innerHTML = '<tr><td colspan="4" class="no-data-message">No vesting schedules found.</td></tr>';
            return;
        }
        
        vestingData.forEach((data) => {
            const row = tbody.insertRow();
            
            const linearBadge = data.isLinear ? '<div style="font-size: 10px; color: #10B981;">ðŸ“ˆ Linear Vesting</div>' : '';
            
            let nextUnlockDisplay = '<span style="color: #666;">No upcoming unlocks</span>';
            
            if (data.releasableNow > 0) {
                nextUnlockDisplay = `
                    <div><strong>Available Now:</strong> ${this.formatTokenAmount(data.releasableNow, data.decimals)}</div>
                `;
            } else if (data.nextUnlockTime > 0 && data.nextUnlockAmount > 0) {
                const unlockDate = new Date(data.nextUnlockTime * 1000);
                const now = new Date();
                const timeDiff = unlockDate - now;
                const daysUntilUnlock = Math.ceil(timeDiff / (1000 * 60 * 60 * 24));
                
                nextUnlockDisplay = `
                    <div><strong>Next Unlock:</strong> ${this.formatTokenAmount(data.nextUnlockAmount, data.decimals)}</div>
                    <div><strong>Date:</strong> ${unlockDate.toLocaleDateString()}</div>
                    <div style="font-size: 11px;">
                        (in ${daysUntilUnlock} day${daysUntilUnlock !== 1 ? 's' : ''})
                    </div>
                `;
            } else if (data.remaining > 0 && data.releasableNow === 0n) {
                const currentTime = Math.floor(Date.now() / 1000);
                if (currentTime < data.startTime + data.duration) {
                    const nextUnlockTime = data.startTime + data.duration;
                    const unlockDate = new Date(nextUnlockTime * 1000);
                    nextUnlockDisplay = `
                        <div><strong>Final Unlock:</strong> ${this.formatTokenAmount(data.remaining, data.decimals)}</div>
                        <div><strong>Date:</strong> ${unlockDate.toLocaleDateString()}</div>
                    `;
                }
            }
            
            row.innerHTML = `
                <td>
                    <div><strong>${data.ticker}</strong></div>
                    <div style="font-size: 11px;">${data.type}</div>
                    ${linearBadge}
                </td>
                <td>
                    <div><strong>Total:</strong> ${this.formatTokenAmount(data.allocated, data.decimals)}</div>
                    <div><strong>Claimed:</strong> ${this.formatTokenAmount(data.released, data.decimals)}</div>
                    <div><strong>Remaining:</strong> ${this.formatTokenAmount(data.remaining, data.decimals)}</div>
                    <div style="font-size: 10px;">Beneficiary: ${truncateAddress(data.beneficiary)}</div>
                </td>
                <td>
                    <div><strong>Start:</strong> ${new Date(data.startTime * 1000).toLocaleDateString()}</div>
                    <div><strong>End:</strong> ${new Date((data.startTime + data.duration) * 1000).toLocaleDateString()}</div>
                    <div style="font-size: 11px;">Duration: ${Math.floor(data.duration / 86400)} days</div>
                </td>
                <td>
                    ${nextUnlockDisplay}
                </td>
            `;
        });
    }

    formatTokenAmount(amount, decimals) {
        if (!amount || amount === 0n) return "0";
        try {
            const formatted = ethers.formatUnits(amount, decimals);
            return Number(formatted).toLocaleString('en-US', { 
                minimumFractionDigits: 0, 
                maximumFractionDigits: 4 
            });
        } catch (e) {
            return amount.toString();
        }
    }
}

// ===== APPROVAL CHECKER CLASS =====
class ApprovalChecker {
    constructor() {
        this.userApprovals = [];
        this.domElements = {};
        this.currentUserAddress = null;
        this.cacheDOMElements();
        this.setupEventListeners();
        this.setupWalletListeners();
    }

    cacheDOMElements() {
        this.domElements.initialRow = document.getElementById('initialRow');
        this.domElements.noApprovalsMessage = document.getElementById('noApprovalsMessage');
        this.domElements.approvalsTable = document.getElementById('approvalsTable');
        this.domElements.approvalsTbody = this.domElements.approvalsTable?.querySelector('tbody');
    }

    setupEventListeners() {
        this.attachInitialRowListener();
        
        if (this.domElements.noApprovalsMessage) {
            this.domElements.noApprovalsMessage.addEventListener('click', async () => {
                const allowed = await verifyInkyBalance();
                if (allowed) {
                    await this.analyzeApprovals();
                }
            });
        }
    }

    attachInitialRowListener() {
        const initialRow = document.getElementById('initialRow');
        if (initialRow) {
            const newRow = initialRow.cloneNode(true);
            initialRow.parentNode.replaceChild(newRow, initialRow);
            
            newRow.addEventListener('click', async () => {
                const allowed = await verifyInkyBalance();
                if (allowed) {
                    await this.analyzeApprovals();
                }
            });

            const analyzeLink = newRow.querySelector('.analyze-link');
            if (analyzeLink) {
                analyzeLink.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const allowed = await verifyInkyBalance();
                    if (allowed) {
                        await this.analyzeApprovals();
                    }
                });
            }
        }
    }

    setupWalletListeners() {
        if (window.walletManager) {
            const originalOnDisconnected = walletManager.onWalletDisconnected;
            const originalOnConnected = walletManager.onWalletConnected;
            
            walletManager.onWalletDisconnected = () => {
                console.log('ApprovalChecker: Wallet disconnected');
                this.currentUserAddress = null;
                this.resetApprovalsTable();
                if (originalOnDisconnected) {
                    originalOnDisconnected.call(walletManager);
                }
            };

            walletManager.onWalletConnected = async () => {
                console.log('ApprovalChecker: Wallet connected');
                const newAddress = walletManager.getUserAddress();

                const addressChanged = this.currentUserAddress && this.currentUserAddress !== newAddress;
                
                if (addressChanged) {
                    console.log('ApprovalChecker: Account changed');
                    this.resetApprovalsTable();
                }
                
                this.currentUserAddress = newAddress;
                
                if (originalOnConnected) {
                    originalOnConnected.call(walletManager);
                }
            };
        }

        this.startConnectionMonitor();
    }

    startConnectionMonitor() {
        setInterval(async () => {
            const currentAddress = walletManager.getUserAddress();

            if (!currentAddress && this.currentUserAddress) {
                console.log('ApprovalChecker: Wallet disconnected');
                this.currentUserAddress = null;
                this.resetApprovalsTable();
            }
            else if (currentAddress && this.currentUserAddress && currentAddress !== this.currentUserAddress) {
                console.log('ApprovalChecker: Account changed');
                this.currentUserAddress = currentAddress;
                this.resetApprovalsTable();
            }
            else if (currentAddress && !this.currentUserAddress) {
                console.log('ApprovalChecker: New connection');
                this.currentUserAddress = currentAddress;
            }
        }, 1000);
    }

    resetApprovalsTable() {
        console.log('ApprovalChecker: Resetting table...');
        this.userApprovals = [];
        
        const tbody = document.querySelector('#approvalsTable tbody');
        if (tbody) {
            tbody.innerHTML = `
                <tr id="initialRow">
                    <td colspan="4" class="no-data-message">
                        Click <span class="analyze-link">here</span> to view your wallet approvals
                    </td>
                </tr>
            `;
            
            setTimeout(() => this.attachInitialRowListener(), 50);
        }
        
        const noApprovalsMsg = document.getElementById('noApprovalsMessage');
        if (noApprovalsMsg) {
            noApprovalsMsg.style.display = 'none';
        }
    }

    async analyzeApprovals() {
        if (!walletManager.isConnected()) {
            showError("Please connect your wallet first.");
            return;
        }

        this.currentUserAddress = walletManager.getUserAddress();

        showLoader("ðŸ” Scanning approval events history...This may take a few minutes.");

        try {
            this.showLoadingMessage();
            
            this.userApprovals = await this.robustApprovalScan();
            this.displayApprovals();

        } catch (error) {
            console.error("Approval analysis failed:", error);
            showError("Failed to analyze approvals");
        } finally {
            hideLoader();
        }
    }

    async robustApprovalScan() {
        const userAddress = walletManager.getUserAddress();

        if (userAddress !== this.currentUserAddress) {
            console.log('Account changed during scan, aborting...');
            return [];
        }
        
        const allApprovals = [];
        const tokenList = await fetchTokenList(userAddress);
        
        if (tokenList.length === 0) {
            console.log("No tokens found for this wallet");
            return [];
        }

        console.log(`ðŸ” Scanning ${tokenList.length} tokens for approvals`);

        const allSpenders = await this.getAllApprovalSpendersFromEvents(userAddress);
        console.log(`ðŸ“‹ Found ${allSpenders.length} unique spenders from events`);

        for (const token of tokenList) {
            const tokenApprovals = await this.scanTokenAgainstSpenders(token, userAddress, allSpenders);
            allApprovals.push(...tokenApprovals);
        }

        console.log(`ðŸŽ¯ Total approvals found: ${allApprovals.length}`);
        return allApprovals;
    }

    async getAllApprovalSpendersFromEvents(userAddress) {
        const spenders = new Set();
        
        try {
            const provider = walletManager.getReadProvider();
            const currentBlock = await provider.getBlockNumber();
            
            const fromBlock = 0;
            
            console.log(`ðŸ“¦ Scanning ALL approval events from block ${fromBlock} to ${currentBlock}`);

            const filter = {
                topics: [
                    ethers.id("Approval(address,address,uint256)"),
                    ethers.zeroPadValue(userAddress, 32)
                ],
                fromBlock: fromBlock,
                toBlock: currentBlock
            };

            const logs = await provider.getLogs(filter);
            console.log(`ðŸ“‹ Found ${logs.length} Approval events total`);

            logs.forEach(log => {
                try {
                    const spender = ethers.dataSlice(log.topics[2], 12);
                    if (ethers.isAddress(spender) && spender !== ethers.ZeroAddress) {
                        spenders.add(spender.toLowerCase());
                        console.log(`ðŸŽ¯ Found spender from event: ${spender}`);
                    }
                } catch (e) {
                    console.warn('Failed to decode event log', e);
                }
            });

        } catch (error) {
            console.error("Comprehensive event scanning failed:", error);
            return await this.getApprovalSpendersFallback(userAddress);
        }

        return Array.from(spenders);
    }

    async getApprovalSpendersFallback(userAddress) {
        const spenders = new Set();
        
        try {
            const provider = walletManager.getReadProvider();
            const currentBlock = await provider.getBlockNumber();
            
            const ranges = [
                { from: currentBlock - 100000, to: currentBlock },
                { from: currentBlock - 50000, to: currentBlock },
                { from: currentBlock - 10000, to: currentBlock }
            ];

            for (const range of ranges) {
                try {
                    console.log(`ðŸ”„ Trying range: ${range.from} to ${range.to}`);
                    
                    const filter = {
                        topics: [
                            ethers.id("Approval(address,address,uint256)"),
                            ethers.zeroPadValue(userAddress, 32)
                        ],
                        fromBlock: range.from,
                        toBlock: range.to
                    };

                    const logs = await provider.getLogs(filter);
                    console.log(`ðŸ“‹ Found ${logs.length} events in range ${range.from}-${range.to}`);

                    logs.forEach(log => {
                        try {
                            const spender = ethers.dataSlice(log.topics[2], 12);
                            if (ethers.isAddress(spender) && spender !== ethers.ZeroAddress) {
                                spenders.add(spender.toLowerCase());
                            }
                        } catch (e) {
                            console.warn('Failed to decode event log in fallback');
                        }
                    });

                    if (logs.length > 0) break;

                } catch (rangeError) {
                    console.warn(`Range ${range.from}-${range.to} failed:`, rangeError.message);
                    continue;
                }
            }

        } catch (error) {
            console.error("All fallback methods failed:", error);
        }

        return Array.from(spenders);
    }

    async scanTokenAgainstSpenders(token, userAddress, spenders) {
        const approvals = [];
        
        try {
            const tokenInfo = await this.getTokenInfo(token.contractAddress);
            if (!tokenInfo) {
                return approvals;
            }

            console.log(`ðŸ” Scanning ${tokenInfo.symbol} against ${spenders.length} spenders`);

            const checkPromises = spenders.map(spender =>
                this.checkSingleAllowance(token.contractAddress, userAddress, spender, tokenInfo)
            );

            const checkResults = await Promise.allSettled(checkPromises);
            
            checkResults.forEach(result => {
                if (result.status === 'fulfilled' && result.value) {
                    approvals.push(result.value);
                }
            });

            if (approvals.length > 0) {
                console.log(`âœ… ${tokenInfo.symbol}: Found ${approvals.length} approvals`);
            }

        } catch (error) {
            console.error(`Failed to scan token ${token.contractAddress}:`, error);
        }

        return approvals;
    }

    async checkSingleAllowance(tokenAddress, userAddress, spenderAddress, tokenInfo) {
        try {
            const tokenContract = new ethers.Contract(
                tokenAddress,
                ["function allowance(address owner, address spender) view returns (uint256)"],
                walletManager.getReadProvider()
            );

            const allowance = await tokenContract.allowance(userAddress, spenderAddress);
            
            if (allowance > 0n) {
                console.log(`âœ… APPROVAL FOUND: ${tokenInfo.symbol} â†’ ${spenderAddress}: ${ethers.formatUnits(allowance, tokenInfo.decimals)}`);
                
                return {
                    tokenAddress: tokenAddress,
                    tokenSymbol: tokenInfo.symbol,
                    tokenName: tokenInfo.name,
                    tokenDecimals: tokenInfo.decimals,
                    spenderAddress: spenderAddress,
                    spenderName: await this.getSpenderName(spenderAddress),
                    allowance: allowance,
                    formattedAllowance: ethers.formatUnits(allowance, tokenInfo.decimals)
                };
            }
        } catch (error) {
        }
        
        return null;
    }

    async getTokenInfo(tokenAddress) {
        try {
            const tokenContract = new ethers.Contract(
                tokenAddress, 
                [
                    "function symbol() view returns (string)",
                    "function decimals() view returns (uint8)", 
                    "function name() view returns (string)"
                ], 
                walletManager.getReadProvider()
            );

            const [symbol, decimals, name] = await Promise.all([
                tokenContract.symbol().catch(() => "UNKNOWN"),
                tokenContract.decimals().catch(() => 18),
                tokenContract.name().catch(() => "Unknown Token")
            ]);

            return { symbol, decimals: Number(decimals), name };
        } catch (error) {
            return null;
        }
    }

    async getSpenderName(spenderAddress) {
        try {
            const provider = walletManager.getReadProvider();
            const code = await provider.getCode(spenderAddress);
            return code && code !== "0x" ? "Smart Contract" : "External Address";
        } catch (error) {
            return "Unknown";
        }
    }

    displayApprovals() {
        if (!this.domElements.approvalsTbody) return;

        if (this.userApprovals.length === 0) {
            this.showNoApprovalsMessage();
            return;
        }

        const initialRow = document.getElementById('initialRow');
        if (initialRow) {
            initialRow.style.display = 'none';
        }
        
        const noApprovalsMsg = document.getElementById('noApprovalsMessage');
        if (noApprovalsMsg) {
            noApprovalsMsg.style.display = 'none';
        }

        this.domElements.approvalsTbody.innerHTML = '';
        
        this.userApprovals.forEach((approval, index) => {
            const row = this.domElements.approvalsTbody.insertRow();
            
            const displayAmount = approval.allowance === ethers.MaxUint256 
                ? "Infinite âš ï¸" 
                : Number(approval.formattedAllowance).toLocaleString(undefined, { 
                    maximumFractionDigits: 6 
                });

            row.innerHTML = `
                <td>
                    <div><strong>${approval.tokenSymbol}</strong></div>
                    <div style="font-size: 11px;">${approval.tokenName}</div>
                </td>
                <td>
                    <div><strong>${approval.spenderName}</strong></div>
                    <div style="font-size: 11px;">${approval.spenderAddress}</div>
                </td>
                <td>
                    <div>${displayAmount}</div>
                </td>
                <td>
                    <button class="revoke-btn" data-index="${index}">
                        Revoke
                    </button>
                </td>
            `;
        });

        this.attachRevokeListeners();
    }

    attachRevokeListeners() {
        const revokeButtons = this.domElements.approvalsTbody.querySelectorAll('.revoke-btn');
        revokeButtons.forEach(button => {
            button.addEventListener('click', async (e) => {
                e.preventDefault();
                const index = parseInt(button.getAttribute('data-index'));
                await this.revokeApproval(index);
            });
        });
    }

    showLoadingMessage() {
        if (this.domElements.approvalsTbody) {
            this.domElements.approvalsTbody.innerHTML = `
                <tr>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                </tr>
            `;
        }
    }

    showNoApprovalsMessage() {
        const tbody = document.querySelector('#approvalsTable tbody');
        if (tbody) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="4" class="no-data-message">
                        No approvals found. Click <span class="analyze-link">here</span> to scan again
                    </td>
                </tr>
            `;
            
            const analyzeLink = tbody.querySelector('.analyze-link');
            if (analyzeLink) {
                analyzeLink.addEventListener('click', async (e) => {
                    e.preventDefault();
                    const allowed = await verifyInkyBalance();
                    if (allowed) {
                        await this.analyzeApprovals();
                    }
                });
            }
        }
    }

    async revokeApproval(index) {
        const approval = this.userApprovals[index];
        if (!approval) return;

        showLoader("ðŸ”„ Revoking...");

        try {
            const provider = new ethers.BrowserProvider(window.ethereum);
            const signer = await provider.getSigner();
            
            const tokenContract = new ethers.Contract(
                approval.tokenAddress,
                ["function approve(address spender, uint256 amount) returns (bool)"],
                signer
            );

            const tx = await tokenContract.approve(approval.spenderAddress, 0);
            await tx.wait();

            this.userApprovals.splice(index, 1);
            this.displayApprovals();
            
            showLoader('âœ… Revoked!');
            await new Promise(resolve => setTimeout(resolve, 1500));
            
        } catch (error) {
            showError(error.code === 'ACTION_REJECTED' ? "Rejected" : "Failed");
        } finally {
            hideLoader();
        }
    }
}

// ===== WALLET SCREENER CLASS =====
class WalletScreener {
    constructor() {
        this.analyzedWallets = new Map();
        this.currentWalletData = null;
        this.currentToken = null;
        this.selectedPeriod = '1D';
        this.domElements = {};
        this.contractCache = new Map();
        this.contractNames = new Map();
        this.analysisAbortController = null;
        this.isAnalyzing = false;
        this.refreshInterval = null;
        this.currentWalletAddress = null;
        this.isRefreshing = false;
        this.tokenAnalysisPromises = new Map();
        
        this.cacheDOMElements();
        this.setupEventListeners();
        this.injectCSS();
        this.setupAutoRefresh();
    }

    injectCSS() {
        const style = document.createElement('style');
        style.textContent = `
            .screener-results {
                display: none;
                margin-top: 20px;
            }
            .screener-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 25px;
                margin-bottom: 30px;
            }
            .screener-card {
                background: var(--bg-color-box);
                border-radius: 15px;
                padding: 25px;
                border: 1px solid var(--border-color);
                box-shadow: 0 0 20px rgba(0,0,0,0.3);
                backdrop-filter: blur(10px);
            }
            .screener-card h3 {
                margin: 0 0 15px 0;
                font-size: 18px;
                color: var(--text-color-accent);
                border-bottom: 2px solid var(--border-color);
                padding-bottom: 12px;
                font-weight: 600;
            }
            .screener-card:first-child h3 {
                border-bottom: none;
                margin-bottom: 0;
                padding-bottom: 0;
            }
            .token-selector-section {
                text-align: center;
            }
            .token-selector-section h3 {
                margin-bottom: 0px; 
            }
            .period-selector {
                display: flex;
                gap: 10px;
                justify-content: center;
                flex-wrap: wrap;
            }
            .period-btn {
                padding: 10px 20px;
                border: none;
                background: linear-gradient(270deg, var(--bg-color-gradient-dark), var(--bg-color-main), #6C7A89, var(--bg-color-gradient-dark));
                background-size: 600% 600%;
                color: var(--text-color-light);
                border-radius: 10px;
                cursor: pointer;
                transition: transform 0.3s, box-shadow 0.3s, color 0.3s, background 0.5s;
                font-size: 14px;
                font-weight: 600;
            }
            .period-btn:hover {
                transform: scale(1.05);
                box-shadow: 0 0 15px 3px #6C7A89;
                animation: gradientAnimation 3s ease infinite;
                color: var(--text-color-accent);
            }
            .period-btn.active {
                color: var(--text-color-accent);
                border: 2px solid var(--text-color-accent);
                transform: scale(1.05);
            }
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 20px;
                margin-top: 20px;
            }
            .stat-card {
                background: rgba(255, 255, 255, 0.05);
                padding: 20px;
                border-radius: 12px;
                border: 1px solid var(--border-color);
                text-align: center;
                transition: transform 0.3s ease;
            }
            .stat-value {
                font-size: 16px;
                margin: 8px 0;
                color: var(--text-color-light);
            }
            .stat-label {
                font-size: 12px;
                color: var(--text-color-accent);
                text-transform: uppercase;
                letter-spacing: 1px;
                font-weight: 600;
            }
            .transaction-item {
                padding: 5px;
                border-bottom: 1px solid var(--border-color);
                font-size: 14px;
                transition: all 0.3s ease;
                border-radius: 8px;
                margin-bottom: 8px;
            }
            .transaction-item:last-child {
                border-bottom: none;
                margin-bottom: 0;
            }
            .transaction-amount {
                font-weight: 600;
                font-size: 14px;
            }
            .transaction-in {
                color: #00FA9A;
            }
            .transaction-out {
                color: #FF6B6B;
            }
            #tokenSelectScreener {
                width: 100%;
                max-width: 400px;
                padding: 12px 15px;
                border: 1px solid var(--border-color);
                border-radius: 10px;
                margin: 10px auto;
                background: var(--bg-color-main);
                color: var(--text-color-light);
                font-size: 14px;
                box-shadow: 0 0 10px rgba(0,0,0,0.2);
                transition: all 0.3s ease;
            }
            .token-holdings-list {
                max-height: 400px;
                overflow-y: auto;
                padding-right: 10px;
            }
            .token-holdings-list::-webkit-scrollbar {
                width: 6px;
            }
            .token-holdings-list::-webkit-scrollbar-track {
                background: rgb(68, 75, 82);
                border-radius: 3px;
            }
            .token-holdings-list::-webkit-scrollbar-thumb {
                background: rgb(100, 110, 120);
                border-radius: 3px;
            }
            .holding-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                border: 1px solid var(--border-color);
                margin-bottom: 10px;
                transition: all 0.3s ease;
            }
            .token-symbol {
                font-weight: 600;
                font-size: 15px;
                color: var(--text-color-light);
            }
            .token-amount {
                font-size: 14px;
                color: var(--text-color-accent);
                font-weight: 600;
            }
            .holdings-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
                padding-bottom: 12px;
                border-bottom: 2px solid var(--border-color);
            }
            .token-count {
                font-size: 12px;
                color: var(--text-color-accent);
                background: rgba(229, 192, 123, 0.1);
                padding: 6px 12px;
                border-radius: 15px;
                font-weight: 600;
                line-height: 1; 
            }
            .transactions-list {
                max-height: 400px;
                overflow-y: auto;
                padding-right: 10px;
            }
            .transactions-list::-webkit-scrollbar {
                width: 6px;
            }
            .transactions-list::-webkit-scrollbar-track {
                background: rgb(68, 75, 82);
                border-radius: 3px;
            }
            .transactions-list::-webkit-scrollbar-thumb {
                background: rgb(100, 110, 120);
                border-radius: 3px;
            }
            .transaction-details {
                font-size: 12px;
                color: #A0AEC0;
                margin-top: 7px;
            }
            .transaction-address {
                font-family: 'Courier New', monospace;
                color: var(--text-color-light);
            }
            .section-title {
                font-size: 24px;
                font-weight: 700;
                color: var(--text-color-accent);
                margin-bottom: 30px;
                text-align: center;
                text-shadow: 0 0 10px rgba(229, 192, 123, 0.3);
            }
            .analysis-subtitle {
                font-size: 16px;
                color: var(--text-color-light);
                margin-bottom: 25px;
                text-align: center;
                opacity: 0.9;
            }
            .auto-refresh-indicator {
                display: inline-block;
                width: 8px;
                height: 8px;
                background: #00FA9A;
                border-radius: 50%;
                margin-left: 8px;
                animation: pulse 2s infinite;
            }
            .flow-values {
                display: flex;
                flex-direction: column;
                margin: 12px 0;
                text-align: center;
            }
            .flow-item {
                display: block;
                font-size: 13px;
            }
            .flow-label {
                color: var(--text-color-light);
                font-weight: 500;
                margin-right: 8px;
            }
            .flow-value {
                font-weight: 600;
                font-size: 13px;
            }
            @keyframes pulse {
                0% { opacity: 1; }
                50% { opacity: 0.4; }
                100% { opacity: 1; }
            }
            .analysis-placeholder {
                color: #A0AEC0;
                font-style: italic;
            }
        `;
        document.head.appendChild(style);
    }

    cacheDOMElements() {
        this.domElements.tokenAddressInput = document.getElementById('tokenAddressScreener');
        this.domElements.screenerButton = document.getElementById('screenerButton');
        this.domElements.screenerResults = document.createElement('div');
        this.domElements.screenerResults.className = 'screener-results';
        
        const screenerTool = document.getElementById('screener-tool');
        if (screenerTool) {
            screenerTool.appendChild(this.domElements.screenerResults);
        }
    }

    setupEventListeners() {
        if (this.domElements.screenerButton) {
            this.domElements.screenerButton.replaceWith(this.domElements.screenerButton.cloneNode(true));
            this.domElements.screenerButton = document.getElementById('screenerButton');
            
            this.domElements.screenerButton.addEventListener('click', async (e) => {
                e.preventDefault();
                const allowed = await verifyInkyBalance();
                if (allowed) {
                    await this.analyzeWallet();
                }
            });
        }
    }

    setupAutoRefresh() {
        this.refreshInterval = setInterval(() => {
            if (this.currentWalletAddress && this.domElements.screenerResults.style.display === 'block' && !this.isRefreshing) {
                this.refreshWalletData();
            }
        }, 10000);
    }

    async refreshWalletData() {
        if (!this.currentWalletAddress || this.isRefreshing) return;
        
        this.isRefreshing = true;
        
        try {
            console.log('ðŸ”„ Auto-refreshing wallet data...');
            const newWalletData = await this.fetchWalletData(this.currentWalletAddress);
            
            if (this.hasDataChanged(this.currentWalletData, newWalletData)) {
                this.currentWalletData = newWalletData;
                this.updateDisplayedData();
                console.log('âœ… Wallet data refreshed');
            }
        } catch (error) {
            console.error('Auto-refresh failed:', error);
        } finally {
            this.isRefreshing = false;
        }
    }

    hasDataChanged(oldData, newData) {
        if (!oldData || !newData) return true;
        
        if (oldData.tokens.length !== newData.tokens.length) return true;
        
        for (let i = 0; i < oldData.tokens.length; i++) {
            if (oldData.tokens[i].balance !== newData.tokens[i].balance) {
                return true;
            }
        }
        
        const oldTransactions = oldData.latestTransactions || {};
        const newTransactions = newData.latestTransactions || {};
        
        const oldTokensWithTx = Object.keys(oldTransactions).filter(token => oldTransactions[token] !== null);
        const newTokensWithTx = Object.keys(newTransactions).filter(token => newTransactions[token] !== null);
        
        if (oldTokensWithTx.length !== newTokensWithTx.length) return true;
        
        for (const tokenAddress of oldTokensWithTx) {
            const oldTx = oldTransactions[tokenAddress];
            const newTx = newTransactions[tokenAddress];
            
            if (!oldTx && newTx) return true;
            if (oldTx && !newTx) return true;
            
            if (oldTx && newTx && oldTx.hash !== newTx.hash) {
                return true;
            }
        }
        
        return false;
    }

    updateDisplayedData() {
        if (!this.currentWalletData) return;
        
        const holdingsList = document.querySelector('.token-holdings-list');
        if (holdingsList) {
            holdingsList.innerHTML = this.generateAllHoldingsHTML();
        }
        
        const transactionsList = document.querySelector('.transactions-list');
        if (transactionsList) {
            transactionsList.innerHTML = this.generateAllTransactionsHTML();
        }
        
        const tokenCount = document.querySelector('.token-count');
        if (tokenCount) {
            tokenCount.textContent = `${this.currentWalletData.tokens.length} tokens`;
        }
        
        this.setupTokenDropdown();
    }

    async analyzeWallet() {
        let walletAddress = this.domElements.tokenAddressInput.value.trim();

        if (!walletAddress) {
            if (!walletManager.isConnected()) {
                showError("Please connect your wallet first or enter a wallet address.");
                return;
            }
            walletAddress = walletManager.getUserAddress();
            this.domElements.tokenAddressInput.value = walletAddress;
        }

        if (!ethers.isAddress(walletAddress)) {
            showError("Invalid wallet address format. Please enter a valid 0x address.");
            return;
        }

        try {
            const code = await walletManager.getReadProvider().getCode(walletAddress);
            if (code && code !== "0x") {
                showError("This address is a smart contract, not a wallet address.");
                return;
            }
        } catch (error) {
            console.error("Error checking contract code:", error);
            showError("Unable to verify the address type. Please try again.");
            return;
        }

        if (this.currentWalletAddress && this.currentWalletAddress !== walletAddress) {
            console.log('ðŸ”„ New wallet address, clearing token analysis cache');
            this.tokenAnalysisPromises.clear();
        }

        this.analysisAbortController = new AbortController();
        this.isAnalyzing = true;
        
        this.setupEscapeListener();

        showLoader("ðŸ” Analysis in progress...");

        try {
            this.currentWalletAddress = walletAddress;
            this.currentWalletData = await this.fetchWalletData(walletAddress, this.analysisAbortController.signal);
            
            if (this.analysisAbortController.signal.aborted) {
                return;
            }
            
            await this.displayWalletAnalysis();
            
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('Analysis cancelled by user');
                return;
            }
            
            console.error("Wallet analysis failed:", error);
            showError("Failed to analyze wallet. Check console for details.");
            hideLoader();
        } finally {
            this.cleanupAnalysis();
        }
    }

    async fetchWalletData(walletAddress, signal) {
        console.log(`ðŸ” Fetching data for wallet: ${walletAddress}`);
        
        if (signal?.aborted) throw new DOMException('Aborted', 'AbortError');
        
        const [tokenList, nativeBalance] = await Promise.all([
            fetchTokenList(walletAddress),
            getNativeBalance(walletAddress)
        ]);
        
        if (signal?.aborted) throw new DOMException('Aborted', 'AbortError');
        
        const nativeToken = {
            contractAddress: 'native',
            symbol: 'tNXRA',
            balance: nativeBalance,
            decimals: 18,
            name: 'Nexera Testnet Native Token',
            isNative: true
        };

        tokenList.sort((a, b) => {
            const valueA = this.calculateTokenValue(a.balance, a.decimals);
            const valueB = this.calculateTokenValue(b.balance, b.decimals);
            return valueB - valueA;
        });

        const sortedTokens = nativeBalance > 0n ? [nativeToken, ...tokenList] : [...tokenList];

        if (signal?.aborted) throw new DOMException('Aborted', 'AbortError');

        const transactionPromises = sortedTokens.map(token => 
            this.fetchTokenTransactions(walletAddress, token.contractAddress, token.isNative)
                .catch(error => {
                    console.error(`Error fetching transactions for ${token.symbol}:`, error);
                    return [];
                })
        );
        
        const transactionsResults = await Promise.all(transactionPromises);
        
        if (signal?.aborted) throw new DOMException('Aborted', 'AbortError');

        const latestTransactions = {};
        transactionsResults.forEach((transactions, index) => {
            const token = sortedTokens[index];
            latestTransactions[token.contractAddress] = transactions.length > 0 ? transactions[0] : null;
        });

        return {
            address: walletAddress,
            tokens: sortedTokens,
            latestTransactions: latestTransactions,
            timestamp: Date.now()
        };
    }

    calculateTokenValue(balance, decimals) {
        try {
            return parseFloat(ethers.formatUnits(balance, decimals));
        } catch (e) {
            return 0;
        }
    }

    async fetchTokenTransactions(walletAddress, tokenAddress, isNative = false) {
        let url = '';
        
        if (tokenAddress === 'native' || isNative) {
            url = `${NXRA_CHAIN.API_BASE_URL}api?module=account&action=txlist&address=${walletAddress}&page=1&offset=10&sort=desc`;
        } else {
            url = `${NXRA_CHAIN.API_BASE_URL}api?module=account&action=tokentx&address=${walletAddress}&contractaddress=${tokenAddress}&page=1&offset=10&sort=desc`;
        }

        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            
            const data = await response.json();
            
            if (data.status === '1' && Array.isArray(data.result)) {
                let transactions = data.result.map(tx => {
                    const value = isNative ? BigInt(tx.value) : BigInt(tx.value || '0');
                    const from = tx.from || '';
                    const to = tx.to || '';
                    
                    return {
                        hash: tx.hash,
                        from: from,
                        to: to,
                        value: value,
                        timestamp: parseInt(tx.timeStamp),
                        direction: from.toLowerCase() === walletAddress.toLowerCase() ? 'out' : 'in',
                        isNative: isNative
                    };
                });

                if (isNative) {
                    transactions = await this.filterNativeWalletTransactions(transactions, walletAddress);
                } else {
                    const filteredTransactions = [];
                    for (const tx of transactions) {
                        if (tx.direction === 'out') {
                            const isToContract = await this.isContractAddress(tx.to);
                            if (!isToContract) {
                                filteredTransactions.push(tx);
                            }
                        } else if (tx.direction === 'in') {
                            const isFromContract = await this.isContractAddress(tx.from);
                            if (!isFromContract) {
                                filteredTransactions.push(tx);
                            }
                        }
                    }
                    transactions = filteredTransactions;
                }

                return transactions;
            }
            
            return [];
        } catch (error) {
            console.error("Error fetching transactions for", tokenAddress, error);
            return [];
        }
    }

    async filterNativeWalletTransactions(transactions, walletAddress) {
        const filteredTransactions = [];
        
        for (const tx of transactions) {
            if (tx.direction === 'out') {
                const isContract = await this.isContractAddress(tx.to);
                if (!isContract) {
                    filteredTransactions.push(tx);
                }
            } else if (tx.direction === 'in') {
                const isContract = await this.isContractAddress(tx.from);
                if (!isContract) {
                    filteredTransactions.push(tx);
                }
            }
        }
        
        return filteredTransactions;
    }

    async isContractAddress(address) {
        if (this.contractCache.has(address)) {
            return this.contractCache.get(address);
        }
        
        try {
            const code = await walletManager.getReadProvider().getCode(address);
            const isContract = !(!code || code === "0x");
            this.contractCache.set(address, isContract);
            return isContract;
        } catch (error) {
            return false;
        }
    }

    async displayWalletAnalysis() {
        if (!this.currentWalletData) return;

        this.domElements.screenerResults.innerHTML = this.generateResultsHTML();
        this.domElements.screenerResults.style.display = 'block';

        this.setupTokenDropdown();
        this.setupResultsEventListeners();
        
        this.resetDetailedAnalysis();
        
        hideLoader();
    }

    generateResultsHTML() {
        return `
            <div class="analysis-subtitle">
                Analyzing address: ${truncateAddress(this.currentWalletData.address)}
                <span class="auto-refresh-indicator" title="Auto-refresh active"></span>
            </div>
            
            <div class="screener-grid">
                <div class="screener-card">
                    <div class="holdings-header">
                        <h3>ðŸ’° Token Holdings</h3>
                        <span class="token-count">${this.currentWalletData.tokens.length} tokens</span>
                    </div>
                    <div class="token-holdings-list">
                        ${this.generateAllHoldingsHTML()}
                    </div>
                </div>

                <div class="screener-card">
                    <h3>ðŸ§¾ Latest Transactions</h3>
                    <div class="transactions-list">
                        ${this.generateAllTransactionsHTML()}
                    </div>
                </div>
            </div>

            <div class="token-selector-section">
                <h3>Detailed Token Analysis</h3>
                <select id="tokenSelectScreener">
                    <option value="">Select a token for detailed analysis...</option>
                </select>
                
                <div class="period-selector">
                    <button class="period-btn active" data-period="1D">24H</button>
                    <button class="period-btn" data-period="1W">1 Week</button>
                    <button class="period-btn" data-period="1M">1 Month</button>
                    <button class="period-btn" data-period="1Y">1 Year</button>
                    <button class="period-btn" data-period="All">All Time</button>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Cash Flow</div>
                        <div class="flow-values">
                            <div class="flow-item">
                                <span class="flow-label">Inflow:</span>
                                <span class="flow-value analysis-placeholder" id="inflowValue">-</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-label">Outflow:</span>
                                <span class="flow-value analysis-placeholder" id="outflowValue">-</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-label">Net Flow:</span>
                                <span class="flow-value analysis-placeholder" id="netFlowValue">-</span>
                            </div>
                        </div>
                        <div class="stat-label" id="netFlowPeriod">Selected period</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Holder Details</div>
                        <div class="flow-values">
                            <div class="flow-item">
                                <span class="flow-label">Rank:</span>
                                <span class="flow-value analysis-placeholder" id="holderRankValue">-</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-label">Percentage of supply:</span>
                                <span class="flow-value analysis-placeholder" id="percentageSupplyValue">-</span>
                            </div>
                            <div class="flow-item">
                                <span class="flow-label">Holding period:</span>
                                <span class="flow-value analysis-placeholder" id="holdingPeriodValue">-</span>
                            </div>
                        </div>
                        <div class="stat-label">Global position</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Top Wallet</div>
                        <div class="stat-value analysis-placeholder" id="topWallet">-</div>
                        <div class="stat-label">Most interactions with analyzed token</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Top Contract</div>
                        <div class="stat-value analysis-placeholder" id="topContract">-</div>
                        <div class="stat-label">Most interactions with analyzed wallet</div>
                    </div>
                </div>
            </div>
        `;
    }

    generateAllHoldingsHTML() {
        const { tokens } = this.currentWalletData;
        let html = '';

        tokens.forEach(token => {
            const amount = this.formatTokenAmount(token.balance, token.decimals);
            html += `
                <div class="holding-item">
                    <span class="token-symbol">${token.symbol}</span>
                    <span class="token-amount">${amount}</span>
                </div>
            `;
        });

        return html || '<div class="holding-item">No tokens found</div>';
    }

    generateAllTransactionsHTML() {
        const { latestTransactions, tokens } = this.currentWalletData;
        let html = '';

        tokens.forEach(token => {
            const transaction = latestTransactions[token.contractAddress];
            
            if (transaction) {
                const amount = this.formatTokenAmount(transaction.value, token.decimals);
                const date = new Date(transaction.timestamp * 1000).toLocaleString();
                const directionClass = transaction.direction === 'in' ? 'transaction-in' : 'transaction-out';
                const directionText = transaction.direction === 'in' ? 'Received' : 'Sent';
                const address = transaction.direction === 'in' ? transaction.from : transaction.to;
                
                html += `
                    <div class="transaction-item">
                        <div>
                            <span class="transaction-amount ${directionClass}">
                                ${directionText} ${amount} ${token.symbol}
                            </span>
                            <div class="transaction-details">
                                ${date} â€¢ <span class="transaction-address">${address}</span>
                            </div>
                        </div>
                    </div>
                `;
            }
        });

        return html || '<div class="transaction-item">No transactions found</div>';
    }

    setupTokenDropdown() {
        const select = document.getElementById('tokenSelectScreener');
        if (!select || !this.currentWalletData) return;

        const currentSelection = select.value;
        
        select.innerHTML = '<option value="">Select a token for detailed analysis...</option>';
        
        this.currentWalletData.tokens.forEach(token => {
            if (BigInt(token.balance) > 0n) {
                const option = document.createElement('option');
                option.value = token.contractAddress;
                option.textContent = `${token.symbol} - ${this.formatTokenAmount(token.balance, token.decimals)}`;
                option.dataset.balance = token.balance.toString();
                option.dataset.decimals = token.decimals.toString();
                option.dataset.symbol = token.symbol;
                select.appendChild(option);
            }
        });

        if (currentSelection && select.querySelector(`option[value="${currentSelection}"]`)) {
            select.value = currentSelection;
            this.currentToken = currentSelection;
        } else {
            this.currentToken = null;
        }
    }

    setupResultsEventListeners() {
        const tokenSelect = document.getElementById('tokenSelectScreener');
        if (tokenSelect) {
            tokenSelect.addEventListener('change', async (e) => {
                this.currentToken = e.target.value;
                
                if (this.currentToken) {
                    this.selectedPeriod = '1D';
                    
                    const periodButtons = document.querySelectorAll('.period-btn');
                    periodButtons.forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.period === '1D') {
                            btn.classList.add('active');
                        }
                    });
                    
                    showLoader("ðŸ” Scanning transactions history...This may take a few minutes.");
                    
                    try {
                        await this.updateTokenAnalysis();
                    } catch (error) {
                        console.error("Token analysis failed:", error);
                        showError("Failed to analyze selected token");
                    } finally {
                        hideLoader();
                    }
                } else {
                    this.resetDetailedAnalysis();
                }
            });
        }

        const periodButtons = document.querySelectorAll('.period-btn');
        periodButtons.forEach(btn => {
            btn.addEventListener('click', async (e) => {
                if (!this.currentToken) {
                    showError("Please select a token first");
                    return;
                }

                periodButtons.forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                this.selectedPeriod = e.target.dataset.period;
                
                showLoader("ðŸ” Analysis in progress...");
                
                try {
                    await this.updateTokenAnalysis();
                } catch (error) {
                    console.error("Period analysis failed:", error);
                    showError("Failed to update period analysis");
                } finally {
                    hideLoader();
                }
            });
        });
    }

    resetDetailedAnalysis() {
        const elementsToReset = [
            'inflowValue', 'outflowValue', 'netFlowValue', 'holderRankValue',
            'percentageSupplyValue', 'holdingPeriodValue', 'topWallet', 'topContract'
        ];

        elementsToReset.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = '-';
                element.classList.add('analysis-placeholder');
            }
        });

        const netFlowPeriod = document.getElementById('netFlowPeriod');
        if (netFlowPeriod) {
            netFlowPeriod.textContent = 'Selected period';
        }
    }

    async updateTokenAnalysis() {
        if (!this.currentToken || !this.currentWalletData) {
            console.warn("No token selected or wallet data available");
            return;
        }

        if (this.isAnalyzing) {
            console.log('Analysis already in progress');
            return;
        }

        this.isAnalyzing = true;
        this.analysisAbortController = new AbortController();
        this.setupEscapeListener();

        const cacheKey = `${this.currentToken}_${this.selectedPeriod}`;
        
        const cachedAnalysis = this.tokenAnalysisPromises.get(cacheKey);
        if (cachedAnalysis) {
            try {
                const cachedResult = await cachedAnalysis;
                console.log('ðŸ“¦ Using cached analysis');
                this.updateStatsDisplay(cachedResult);
                this.cleanupAnalysis();
                return;
            } catch (error) {
                this.tokenAnalysisPromises.delete(cacheKey);
            }
        }

        try {
            const tokenData = this.currentWalletData.tokens.find(t => t.contractAddress === this.currentToken);
            if (!tokenData) {
                console.warn("Token data not found for:", this.currentToken);
                this.cleanupAnalysis();
                return;
            }

            console.log(`ðŸ”„ Starting token analysis for ${tokenData.symbol} (${this.selectedPeriod})`);
            
            if (this.analysisAbortController.signal.aborted) {
                return;
            }
            
            const allTransactions = await this.fetchAllTokenTransactions(
                this.currentWalletData.address, 
                this.currentToken
            );

            if (this.analysisAbortController.signal.aborted) {
                return;
            }

            const filteredTransactions = this.filterTransactionsByPeriod(allTransactions, this.selectedPeriod);
            console.log(`ðŸ“Š Found ${filteredTransactions.length} transactions for period ${this.selectedPeriod}`);

            const firstTransactionTimestamp = await this.getFirstTransactionDate(
                this.currentWalletData.address, 
                this.currentToken
            );
            
            if (this.analysisAbortController.signal.aborted) {
                return;
            }
            
            const holdingPeriod = this.calculateHoldingPeriod(firstTransactionTimestamp);

            const [netFlow, topWallet, topContract, holderRankResult] = await Promise.all([
                this.calculateRealNetFlow(filteredTransactions, tokenData.decimals),
                this.findTopWalletInteraction(filteredTransactions),
                this.findTopContractInteraction(filteredTransactions),
                this.getExactHolderRanking(this.currentWalletData.address, this.currentToken, tokenData.balance)
            ]);

            if (this.analysisAbortController.signal.aborted) {
                return;
            }

            console.log(`âœ… Analysis completed:`, {
                netFlow: netFlow.net,
                topWallet,
                topContract,
                holderRank: holderRankResult.rank,
                holdingPeriod
            });

            const result = {
                netFlow,
                topWallet,
                topContract,
                holderRankResult,
                holdingPeriod
            };

            this.tokenAnalysisPromises.set(cacheKey, Promise.resolve(result));
            this.updateStatsDisplay(result);

        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('Token analysis cancelled by user');
                return;
            }
            
            console.error("âŒ Token analysis update failed:", error);
            this.updateStatsDisplay({
                netFlow: { net: 0, inflow: 0, outflow: 0, transactionCount: 0 },
                topWallet: 'Error',
                topContract: 'Error',
                holderRankResult: { rank: 'Error', percentage: 'N/A', displayText: 'Error' },
                holdingPeriod: 'Error'
            });
        } finally {
            this.cleanupAnalysis();
        }
    }

    async fetchAllTokenTransactions(walletAddress, tokenAddress) {
        let url = '';
        const isNative = tokenAddress === 'native';
        
        if (isNative) {
            url = `${NXRA_CHAIN.API_BASE_URL}api?module=account&action=txlist&address=${walletAddress}&startblock=0&endblock=99999999&sort=desc`;
        } else {
            url = `${NXRA_CHAIN.API_BASE_URL}api?module=account&action=tokentx&address=${walletAddress}&contractaddress=${tokenAddress}&startblock=0&endblock=99999999&sort=desc`;
        }

        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            
            const data = await response.json();
            
            if (data.status === '1' && Array.isArray(data.result)) {
                let transactions = data.result.map(tx => {
                    const value = isNative ? BigInt(tx.value) : BigInt(tx.value || '0');
                    const from = tx.from || '';
                    const to = tx.to || '';
                    
                    return {
                        hash: tx.hash,
                        from: from,
                        to: to,
                        value: value,
                        timestamp: parseInt(tx.timeStamp),
                        direction: from.toLowerCase() === walletAddress.toLowerCase() ? 'out' : 'in',
                        isNative: isNative
                    };
                });

                if (isNative) {
                    transactions = await this.filterNativeWalletTransactions(transactions, walletAddress);
                }

                return transactions;
            }
            
            return [];
        } catch (error) {
            console.error("Error fetching all transactions for", tokenAddress, error);
            return [];
        }
    }

    filterTransactionsByPeriod(transactions, period) {
        const now = Math.floor(Date.now() / 1000);
        let startTime;

        switch (period) {
            case '1D': startTime = now - 86400; break;
            case '1W': startTime = now - 604800; break;
            case '1M': startTime = now - 2592000; break;
            case '1Y': startTime = now - 31536000; break;
            default: startTime = 0;
        }

        return transactions.filter(tx => tx.timestamp >= startTime);
    }

    async getFirstTransactionDate(walletAddress, tokenAddress) {
        try {
            const isNative = tokenAddress === 'native';
            let url = '';
            
            if (isNative) {
                url = `${NXRA_CHAIN.API_BASE_URL}api?module=account&action=txlist&address=${walletAddress}&startblock=0&endblock=99999999&sort=asc&page=1&offset=1`;
            } else {
                url = `${NXRA_CHAIN.API_BASE_URL}api?module=account&action=tokentx&address=${walletAddress}&contractaddress=${tokenAddress}&startblock=0&endblock=99999999&sort=asc&page=1&offset=1`;
            }

            const response = await fetch(url);
            if (!response.ok) return null;
            
            const data = await response.json();
            if (data.status === '1' && data.result && data.result.length > 0) {
                const firstTx = data.result[0];
                return parseInt(firstTx.timeStamp);
            }
            
            return null;
        } catch (error) {
            console.error("Error fetching first transaction:", error);
            return null;
        }
    }

    calculateHoldingPeriod(firstTransactionTimestamp) {
        if (!firstTransactionTimestamp) return 'Unknown';
        
        const firstTxDate = new Date(firstTransactionTimestamp * 1000);
        const now = new Date();
        const diffTime = Math.abs(now - firstTxDate);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        
        return `${diffDays} days`;
    }

    calculateRealNetFlow(transactions, decimals) {
        let totalInflow = 0n;
        let totalOutflow = 0n;

        transactions.forEach(tx => {
            if (tx.direction === 'in') {
                totalInflow += tx.value;
            } else {
                totalOutflow += tx.value;
            }
        });

        const inflowFormatted = parseFloat(ethers.formatUnits(totalInflow, decimals));
        const outflowFormatted = parseFloat(ethers.formatUnits(totalOutflow, decimals));
        const netFormatted = inflowFormatted - outflowFormatted;

        return {
            net: netFormatted,
            inflow: inflowFormatted,
            outflow: outflowFormatted,
            transactionCount: transactions.length
        };
    }

    async findTopWalletInteraction(transactions) {
        const walletCounts = {};
        
        for (const tx of transactions) {
            const oppositeAddress = tx.direction === 'in' ? tx.from : tx.to;
            if (!oppositeAddress || oppositeAddress === '0x0000000000000000000000000000000000000000') continue;
            
            const isContract = await this.isContractAddress(oppositeAddress);
            if (!isContract) {
                walletCounts[oppositeAddress] = (walletCounts[oppositeAddress] || 0) + 1;
            }
        }

        const topWallet = Object.entries(walletCounts).sort((a, b) => b[1] - a[1])[0];
        return topWallet ? `${topWallet[0]} (${topWallet[1]} tx)` : 'No wallet interactions';
    }

    async findTopContractInteraction(transactions) {
        console.log('ðŸ” [TOP CONTRACT - NATIVE ANALYSIS]');
        
        if (!this.currentWalletData) return 'No wallet data';
        
        try {
            const nativeTransactions = await this.fetchNativeTransactionsForPeriod(
                this.currentWalletData.address,
                this.selectedPeriod
            );
            
            console.log('ðŸ“„ Native transactions found:', nativeTransactions.length);
            
            const contractCounts = {};
            
            for (const tx of nativeTransactions) {
                console.log(`ðŸ” Native TX: ${tx.from} -> ${tx.to}`);
                
                if (tx.to && 
                    tx.to !== '0x0000000000000000000000000000000000000000' &&
                    tx.to.toLowerCase() !== this.currentWalletData.address.toLowerCase()) {
                    
                    const isContract = await this.isContractAddress(tx.to);
                    console.log(`âœ… ${tx.to} -> ${isContract ? 'CONTRACT' : 'WALLET'}`);
                    
                    if (isContract) {
                        contractCounts[tx.to] = (contractCounts[tx.to] || 0) + 1;
                    }
                }
            }
            
            console.log('ðŸ“Š Native contract counts:', contractCounts);
            const sorted = Object.entries(contractCounts).sort((a, b) => b[1] - a[1]);
            
            return sorted.length > 0 ? 
                `${sorted[0][0]} (${sorted[0][1]} tx)` : 
                'No contract interactions';
                
        } catch (error) {
            console.error('Native contract analysis failed:', error);
            return 'Analysis error';
        }
    }

    async fetchNativeTransactionsForPeriod(walletAddress, period) {
        const now = Math.floor(Date.now() / 1000);
        let startTime;
        
        switch (period) {
            case '1D': startTime = now - 86400; break;
            case '1W': startTime = now - 604800; break;
            case '1M': startTime = now - 2592000; break;
            case '1Y': startTime = now - 31536000; break;
            default: startTime = 0;
        }
        
        const url = `${NXRA_CHAIN.API_BASE_URL}api?module=account&action=txlist&address=${walletAddress}&startblock=0&endblock=99999999&sort=desc`;
        
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.status === '1') {
            return data.result
                .filter(tx => parseInt(tx.timeStamp) >= startTime)
                .map(tx => ({
                    hash: tx.hash,
                    from: tx.from,
                    to: tx.to,
                    value: BigInt(tx.value),
                    timestamp: parseInt(tx.timeStamp)
                }));
        }
        
        return [];
    }

    async getExactHolderRanking(walletAddress, tokenAddress, balance) {
        try {
            if (tokenAddress === 'native') {
                console.log(`ðŸ” Fetching native token ranking for ${walletAddress}`);
                
                try {
                    const totalSupplyNative = 2000000000000000000000000000n;
                    const totalSupplyFormatted = ethers.formatUnits(totalSupplyNative, 18);
                    const totalSupplyNumber = parseFloat(totalSupplyFormatted);
                    
                    const walletBalanceFormatted = ethers.formatUnits(balance, 18);
                    const walletBalanceNumber = parseFloat(walletBalanceFormatted);
                    const percentage = (walletBalanceNumber / totalSupplyNumber) * 100;
                    
                    console.log('ðŸŽ¯ CALCUL AVEC LA VRAIE BALANCE:');
                    console.log('Wallet balance:', walletBalanceNumber, 'NXRA');
                    console.log('Total supply:', totalSupplyNumber, 'NXRA');
                    console.log('Percentage:', percentage.toFixed(6), '%');

                    const walletLower = walletAddress.toLowerCase();
                    let currentPage = 1;
                    const limit = 50;
                    const maxPages = 60;
                    let totalHoldersScanned = 0;

                    while (currentPage <= maxPages) {
                        const addressesUrl = `${NXRA_CHAIN.API_BASE_URL}api/v2/addresses?page=${currentPage}&limit=${limit}`;
                        
                        console.log(`ðŸ“„ Scanning page ${currentPage}...`);
                        
                        const response = await fetch(addressesUrl);
                        if (!response.ok) break;
                        
                        const data = await response.json();
                        
                        if (!data?.items || data.items.length === 0) {
                            console.log('â„¹ï¸ No more data available');
                            break;
                        }
                        
                        const holders = data.items;
                        totalHoldersScanned += holders.length;
                        
                        for (let i = 0; i < holders.length; i++) {
                            const holder = holders[i];
                            const holderAddress = holder.hash || holder.address;
                            
                            if (holderAddress && holderAddress.toLowerCase() === walletLower) {
                                const rank = (currentPage - 1) * limit + i + 1;
                                
                                console.log(`âœ… Rank trouvÃ©: #${rank}`);
                                console.log(`ðŸ“Š Pourcentage rÃ©el: ${percentage.toFixed(6)}%`);
                                
                                return {
                                    rank: `#${rank.toLocaleString()}`,
                                    percentage: percentage.toFixed(6),
                                    displayText: `Rank: #${rank.toLocaleString()}<br>Percentage: ${percentage.toFixed(6)}%`
                                };
                            }
                        }
                        
                        currentPage++;
                    }
                    
                    console.log(`â„¹ï¸ Wallet pas trouvÃ© dans les ${totalHoldersScanned} premiers holders`);
                    console.log(`ðŸ“Š Pourcentage rÃ©el: ${percentage.toFixed(6)}%`);
                    
                    return {
                        rank: `> ${totalHoldersScanned.toLocaleString()}`,
                        percentage: percentage.toFixed(6),
                        displayText: `Rank: > ${totalHoldersScanned.toLocaleString()}<br>Percentage: ${percentage.toFixed(6)}%`
                    };
                    
                } catch (error) {
                    console.log('âŒ Native ranking API failed:', error);
                    return this.getNativeRankingFallback(walletAddress, balance);
                }
            }

            console.log(`ðŸ” Comprehensive holder ranking for ${walletAddress}`);
            
            const tokenContract = new ethers.Contract(tokenAddress, [
                "function totalSupply() view returns (uint256)",
                "function balanceOf(address) view returns (uint256)",
                "function symbol() view returns (string)", 
                "function decimals() view returns (uint8)"
            ], walletManager.getReadProvider());
            
            const [totalSupply, actualBalance, symbol, decimals] = await Promise.all([
                tokenContract.totalSupply(),
                tokenContract.balanceOf(walletAddress),
                tokenContract.symbol().catch(() => "TOKEN"),
                tokenContract.decimals().catch(() => 18)
            ]);
            
            const percentage = (Number(actualBalance) / Number(totalSupply)) * 100;
            const percentageFormatted = percentage.toFixed(6);
            const balanceFormatted = ethers.formatUnits(actualBalance, decimals);
            console.log(`ðŸ“Š ${symbol}: ${balanceFormatted} (${percentageFormatted}%)`);

            const walletLower = walletAddress.toLowerCase();
            let exactRank = null;
            let totalHoldersFound = 0;
            let page = 1;
            const limit = 100;
            const maxPages = 30;

            while (page <= maxPages && exactRank === null) {
                const holdersUrl = `${NXRA_CHAIN.API_BASE_URL}api/v2/tokens/${tokenAddress}/holders?page=${page}&limit=${limit}`;
                
                try {
                    console.log(`ðŸ“„ Scanning ERC-20 page ${page}...`);
                    const response = await fetch(holdersUrl);
                    if (!response.ok) break;
                    
                    const data = await response.json();
                    if (!data?.items?.length) break;
                    
                    const holders = data.items;
                    totalHoldersFound += holders.length;
                    
                    for (let i = 0; i < holders.length; i++) {
                        const holder = holders[i];
                        const addr = holder.address?.hash || holder.address?.address || holder.address;
                        
                        if (addr && String(addr).toLowerCase() === walletLower) {
                            exactRank = (page - 1) * limit + i + 1;
                            console.log(`ðŸŽ¯ EXACT RANK: #${exactRank} (page ${page}, position ${i + 1})`);
                            break;
                        }
                    }
                    
                    page++;
                    
                } catch (error) {
                    console.log(`âŒ Page ${page} failed:`, error.message);
                    break;
                }
            }

            let displayText;
            if (exactRank !== null) {
                displayText = `Rank: #${exactRank.toLocaleString()}<br>Percentage: ${percentageFormatted}%`;
            } else if (totalHoldersFound > 0) {
                displayText = `Rank: > #${totalHoldersFound.toLocaleString()}<br>Percentage: ${percentageFormatted}%`;
            } else {
                displayText = `Rank: No Data<br>Percentage: ${percentageFormatted}%`;
            }

            return {
                rank: exactRank ? `#${exactRank.toLocaleString()}` : (totalHoldersFound > 0 ? `> #${totalHoldersFound.toLocaleString()}` : 'No Data'),
                percentage: percentageFormatted,
                displayText: displayText,
                total: `${totalHoldersFound}+`
            };
            
        } catch (error) {
            console.error("âŒ Comprehensive ranking failed:", error);
            return { 
                rank: 'Error', 
                percentage: 'N/A',
                displayText: 'Error<br>Ranking unavailable',
                total: 'N/A'
            };
        }
    }

    async getNativeRankingFallback(walletAddress, balance) {
        try {
            const totalSupplyNative = 2000000000000000000000000000n;
            const totalSupplyFormatted = ethers.formatUnits(totalSupplyNative, 18);
            const totalSupplyNumber = parseFloat(totalSupplyFormatted);
            
            const holderBalanceFormatted = ethers.formatUnits(balance, 18);
            const holderBalanceNumber = parseFloat(holderBalanceFormatted);
            const percentage = totalSupplyNumber > 0 ? (holderBalanceNumber / totalSupplyNumber) * 100 : 0;
            
            console.log(`ðŸ“Š Fallback calculation:`);
            console.log(`ðŸ“Š Balance: ${holderBalanceNumber} NXRA`);
            console.log(`ðŸ“Š Total supply: ${totalSupplyNumber} NXRA`);
            console.log(`ðŸ“Š Percentage: ${percentage.toFixed(6)}%`);
            
            if (holderBalanceNumber > 1000000) {
                return { 
                    rank: 'Whale', 
                    percentage: percentage.toFixed(6), 
                    displayText: `Rank: Whale<br>Percentage: ${percentage.toFixed(6)}%` 
                };
            } else if (holderBalanceNumber > 100000) {
                return { 
                    rank: 'Dolphin', 
                    percentage: percentage.toFixed(6), 
                    displayText: `Rank: Dolphin<br>Percentage: ${percentage.toFixed(6)}%` 
                };
            } else if (holderBalanceNumber > 10000) {
                return { 
                    rank: 'Shark', 
                    percentage: percentage.toFixed(6), 
                    displayText: `Rank: Shark<br>Percentage: ${percentage.toFixed(6)}%` 
                };
            } else {
                return { 
                    rank: 'Minnow', 
                    percentage: percentage.toFixed(6), 
                    displayText: `Rank: Minnow<br>Percentage: ${percentage.toFixed(6)}%` 
                };
            }
            
        } catch (error) {
            console.error('Error in native ranking fallback:', error);
            return { 
                rank: 'N/A', 
                percentage: 'N/A',
                displayText: 'Native token<br>Ranking unavailable'
            };
        }
    }

    updateStatsDisplay(data) {
        const {
            netFlow,
            topWallet,
            topContract,
            holderRankResult,
            holdingPeriod
        } = data;

        const inflowElement = document.getElementById('inflowValue');
        const outflowElement = document.getElementById('outflowValue');
        const netFlowElement = document.getElementById('netFlowValue');
        const netFlowPeriod = document.getElementById('netFlowPeriod');

        if (inflowElement) {
            inflowElement.textContent = netFlow.inflow.toFixed(4);
            inflowElement.classList.remove('analysis-placeholder');
        }
        if (outflowElement) {
            outflowElement.textContent = netFlow.outflow.toFixed(4);
            outflowElement.classList.remove('analysis-placeholder');
        }
        if (netFlowElement) {
            netFlowElement.textContent = netFlow.net.toFixed(4);
            netFlowElement.classList.remove('analysis-placeholder');
            netFlowElement.style.color = netFlow.net >= 0 ? '#00FA9A' : '#FF6B6B';
        }
        if (netFlowPeriod) {
            netFlowPeriod.textContent = `${this.selectedPeriod} (${netFlow.transactionCount} tx)`;
        }

        const holderRankElement = document.getElementById('holderRankValue');
        const percentageSupplyElement = document.getElementById('percentageSupplyValue');
        const holdingPeriodElement = document.getElementById('holdingPeriodValue');

        if (holderRankElement) {
            holderRankElement.textContent = holderRankResult.rank;
            holderRankElement.classList.remove('analysis-placeholder');
        }
        if (percentageSupplyElement) {
            percentageSupplyElement.textContent = `${holderRankResult.percentage}%`;
            percentageSupplyElement.classList.remove('analysis-placeholder');
        }
        if (holdingPeriodElement) {
            holdingPeriodElement.textContent = holdingPeriod;
            holdingPeriodElement.classList.remove('analysis-placeholder');
        }

        const topWalletElement = document.getElementById('topWallet');
        const topContractElement = document.getElementById('topContract');

        if (topWalletElement) {
            topWalletElement.textContent = topWallet;
            topWalletElement.classList.remove('analysis-placeholder');
        }
        if (topContractElement) {
            topContractElement.textContent = topContract;
            topContractElement.classList.remove('analysis-placeholder');
        }
    }

    formatTokenAmount(balance, decimals) {
        try {
            const formatted = ethers.formatUnits(balance, decimals);
            const num = parseFloat(formatted);
            
            if (num === 0) return '0';
            if (num < 0.0001) return '< 0.0001';
            if (num < 1) return num.toFixed(6);
            if (num < 1000) return num.toFixed(4);
            if (num < 1000000) return (num / 1000).toFixed(2) + 'K';
            return (num / 1000000).toFixed(2) + 'M';
        } catch (e) {
            return '0';
        }
    }

    setupEscapeListener() {
        this.escapeHandler = (event) => {
            if (event.key === 'Escape' && this.isAnalyzing) {
                console.log('ESC pressed - cancelling analysis');
                this.cancelAnalysis();
            }
        };
        
        document.addEventListener('keydown', this.escapeHandler);
    }

    cancelAnalysis() {
        if (this.analysisAbortController) {
            this.analysisAbortController.abort();
        }
        this.cleanupAnalysis();
        hideLoader();
        showError("Analysis interrupted");
        console.log('ðŸ›‘ Analysis cancelled by user');
    }

    cleanupAnalysis() {
        this.isAnalyzing = false;
        
        if (this.escapeHandler) {
            document.removeEventListener('keydown', this.escapeHandler);
            this.escapeHandler = null;
        }
        
        this.analysisAbortController = null;
    }

    destroy() {
        this.cancelAnalysis();
        
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
        }
        this.tokenAnalysisPromises.clear();
        this.contractCache.clear();
        this.analyzedWallets.clear();
    }
}

// ===== INITIALIZATION =====
let multisender = new Multisender();
let riskAnalyzer = new RiskAnalyzer();
let universalVestingAnalyzer = new UniversalVestingAnalyzer();
let approvalChecker = new ApprovalChecker();
let walletScreener = new WalletScreener();

document.getElementById('analyzeTokenButton')?.addEventListener('click', async (e) => {
    e.preventDefault();
    const allowed = await verifyInkyBalance();
    if (allowed) {
        await riskAnalyzer.analyzeToken();
    }
});

document.getElementById('buttonVesting')?.addEventListener('click', async (e) => {
    e.preventDefault();
    const allowed = await verifyInkyBalance();
    if (allowed) {
        await universalVestingAnalyzer.analyzeVesting();
    }
});

if (typeof walletManager !== 'undefined') {
    const originalOnWalletConnected = walletManager.onWalletConnected;
    walletManager.onWalletConnected = function() {
        originalOnWalletConnected.call(this);
        if (approvalChecker) {
            approvalChecker.userApprovals = [];
            approvalChecker.displayApprovals();
        }
    };
}

function setupTabSwitching() {
    DOM_ELEMENTS.navLinks.forEach(tab => {
        tab.addEventListener('click', function(e) {
            e.preventDefault();
            const targetTool = this.getAttribute('data-tool');
            const targetId = `${targetTool}-tool`;
            
            if (this.hasAttribute('disabled')) {
                showError("This feature is coming soon!");
                return;
            } 

            DOM_ELEMENTS.navLinks.forEach(t => t.classList.remove('active'));
            this.classList.add('active');
            
            document.querySelectorAll('#toolContainer > div').forEach(tool => {
                tool.style.display = 'none';
            });
            
            const toolElement = document.getElementById(targetId);
            if (toolElement) toolElement.style.display = 'block';
            history.pushState(null, '', this.href);
        });
    });
}

const hamburger = document.getElementById('hamburger');
const navTabs = document.getElementById('navTabs');

if (hamburger) {
    hamburger.addEventListener('click', function(e) {
        e.stopPropagation();
        navTabs.classList.toggle('active');
        this.classList.toggle('active');
        
        if (navTabs.classList.contains('active')) {
            document.body.style.overflow = 'hidden';
        } else {
            document.body.style.overflow = '';
        }
    });
}

document.addEventListener('click', function(event) {
    if (hamburger && !event.target.closest('header') && navTabs.classList.contains('active')) {
        navTabs.classList.remove('active');
        hamburger.classList.remove('active');
        document.body.style.overflow = '';
    }
});

document.querySelectorAll('.nav-tabs a').forEach(link => {
    link.addEventListener('click', function() {
        if (navTabs.classList.contains('active')) {
            navTabs.classList.remove('active');
            hamburger.classList.remove('active');
            document.body.style.overflow = '';
        }
    });
});

window.addEventListener('resize', function() {
    if (window.innerWidth > 800 && navTabs.classList.contains('active')) {
        navTabs.classList.remove('active');
        hamburger.classList.remove('active');
        document.body.style.overflow = '';
    }
});

document.querySelectorAll('.nav-tabs a').forEach(link => {
    link.addEventListener('click', function(e) {
        e.preventDefault();
        
        document.querySelectorAll('.nav-tabs a').forEach(l => l.classList.remove('active'));
        
        this.classList.add('active');
        
        document.querySelectorAll('#toolContainer > div').forEach(tool => {
            tool.style.display = 'none';
        });
        
        const toolId = this.getAttribute('data-tool') + '-tool';
        const selectedTool = document.getElementById(toolId);
        if (selectedTool) {
            selectedTool.style.display = 'block';
        }
    });
});

document.getElementById('logo').addEventListener('click', () => {
    window.scrollTo({ top: 0, behavior: "smooth" });
});

document.addEventListener('DOMContentLoaded', async () => {
    cacheDOMElements();
    
    setupTabSwitching();

    window.walletManager = new WalletManager();

    await walletManager.autoReconnectWallet();

    const logoDiv = document.getElementById('logo');
    if (logoDiv) {
        logoDiv.addEventListener('click', (e) => {
            e.preventDefault(); 
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    }
    
    document.querySelectorAll('#toolContainer > div').forEach(tool => tool.style.display = 'none');
    
    const activeTab = document.querySelector('.nav-tabs a.active');
    if (activeTab) {
        const defaultToolId = activeTab.getAttribute('data-tool') + '-tool';
        const defaultToolElement = document.getElementById(defaultToolId);
        if (defaultToolElement) {
            defaultToolElement.style.display = 'block';
        }
    }

    walletManager.updateUI();
});
</script>
</body>

</html>
